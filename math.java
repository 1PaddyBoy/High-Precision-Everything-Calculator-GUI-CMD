import java.lang.reflect.Field;
import javafx.scene.color;
import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.HashMap;
import java.util.Collections;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.math.RoundingMode;
import java.math.MathContext;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.concurrent.Callable;

/* NOTE: 
* does currently support pemdos.
* also note that for symplicity the root works backwards so x root t means x to the root t. 
*/

/*
 * Ideas: make something to input custom numbers and stuff. 
 * change up theme 
 * make table for number input or something 
 * add graphing program 
 * add polar coordinate graphing 
 * add file support, save numbers, answers stuff like that. 
 * theme editor, different buttons to change themes and such 
 */

public class math
{
	static boolean opast = false;//stands for operations past, just if the past was an operation, has slight bug with string seperation, do that sometime please
	static int  incurrent = 0;//used as an index between for loops, kinda weird 
	public static boolean dev = true;//this determins whether the dev logs are on, dev logs are just some logs that say stuff, used if you want to see what the program is doing.
	static int tayPres = 1000;//defauly taylor series elements, just placeholder actual values shouldn't really be used as it is changed 
	private static Thread t; //this thread is used later for taylor series multithreading, right now only in exponential 
	private static String threadName; // this holds the name for the thread 
	static double epow = 0;//this is the power of e in the taylor series, used to communicate multithreading 
	static int roundAm = 0;//amount rounding, used to do more auto round amounts but not much used. 
	public static LinkedList<BigDecimal> powered = new LinkedList<BigDecimal>();// this is a list of the things that were powered for use in e power taylor series , linked becuase its a bit faster for input.
	public static LinkedList<BigDecimal> Factorialed = new LinkedList<BigDecimal>();//this is a list of the things that are factorialed for use in the e power taylor series. linked because its faster

	static int MaxPrec = 30000; //this is the amount of precison the taylor series (or maybe in future other but right now only that ) has, should later be controled by a slider.
	static int amountre = 0;//this is a counter for how many things have been calculated in the normal calculator, is used to put the values for ans in the special num hasmap 
	static boolean Taylorchecked;//This holds whether the taylor checked button is pressed at any given time
	static int bigamount = 0;
	static BigDecimal Bpi = new BigDecimal("3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009946576407895126946839835259570982582262052248940772671947826848260147699090264013639443745530506820349625245174939965143142980919065925093722169646151570985838741059788595977297549893016175392846813826868386894277415599185592524595395943104997252468084598727364469584865383673622262609912460805124388439045124413654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767889525213852254995466672782398645659611635488623057745649803559363456817432411251507606947945109659609402522887971089314566913686722874894056010150330861792868092087476091782493858900971490967598526136554978189312978482168299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610213596953623144295248493718711014576540359027993440374200731057853906219838744780847848968332144571386875194350643021845319104848100537061468067491927819119793995206141966342875444064374512371819217999839101591956181467514269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906979207734672218256259966150142150306803844773454920260541466592520149744285073251866600213243408819071048633173464965145390579626856100550810665879699816357473638405257145910289706414011097120628043903975951567715770042033786993600723055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816909152801735067127485832228718352093539657251210835791513698820914442100675103346711031412671113699086585163983150197016515116851714376576183515565088490998985998238734552833163550764791853589322618548963213293308985706420467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325974636673058360414281388303203824903758985243744170291327656180937734440307074692112019130203303801976211011004492932151608424448596376698389522868478312355265821314495768572624334418930396864262434107732269780280731891544110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201855810072936065987648611791045334885034611365768675324944166803962657978771855608455296541266540853061434443185867697514566140680070023787765913440171274947042056223053899456131407112700040785473326993908145466464588079727082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923099079654737612551765675135751782966645477917450112996148903046399471329621073404375189573596145890193897131117904297828564750320319869151402870808599048010941214722131794764777262241425485454033215718530614228813758504306332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120918076383271664162748888007869256029022847210403172118608204190004229661711963779213375751149595015660496318629472654736425230817703675159067350235072835405670403867435136222247715891504953098444893330963408780769325993978054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229246543668009806769282382806899640048243540370141631496589794092432378969070697794223625082216889573837986230015937764716512289357860158816175578297352334460428151262720373431465319777741603199066554187639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764462482468579260395352773480304802900587607582510474709164396136267604492562742042083208566119062545433721315359584506877246029016187667952406163425225771954291629919306455377991403734043287526288896399587947572917464263574552540790914513571113694109119393251910760208252026187985318877058429725916778131496990090192116971737278476847268608490033770242429165130050051683233643503895170298939223345172201381280696501178440874519601212285993716231301711444846409038906449544400619869075485160263275052983491874078668088183385102283345085048608250393021332197155184306354550076682829493041377655279397517546139539846833936383047461199665385815384205685338621867252334028308711232827892125077126294632295639898989358211674562701021835646220134967151881909730381198004973407239610368540664319395097901906996395524530054505806855019567302292191393391856803449039820595510022635353619204199474553859381023439554495977837790237421617271117236434354394782218185286240851400666044332588856986705431547069657474585503323233421073015459405165537906866273337995851156257843229882737231989875714159578111963583300594087306812160287649628674460477464915995054973742562690104903778198683593814657412680492564879855614537234786733039046883834363465537949864192705638729317487233208376011230299113679386270894387993620162951541337142489283072201269014754668476535761647737946752004907571555278196536213239264061601363581559074220202031872776052772190055614842555187925303435139844253223415762336106425063904975008656271095359194658975141310348227693062474353632569160781547818115284366795706110861533150445212747392454494542368288606134084148637767009612071512491404302725386076482363414334623518975766452164137679690314950191085759844239198629164219399490723623464684411739403265918404437805133389452574239950829659122850855582157250310712570126683024029295252201187267675622041542051618416348475651699981161410100299607838690929160302884002691041407928862150784245167090870006992821206604183718065355672525325675328612910424877618258297651579598470356222629348600341587229805349896502262917487882027342092222453398562647669149055628425039127577102840279980663658254889264880254566101729670266407655904290994568150652653053718294127033693137851786090407086671149655834343476933857817113864558736781230145876871266034891390956200993936103102916161528813843790990423174733639480457593149314052976347574811935670911013775172100803155902485309066920376719220332290943346768514221447737939375170344366199104033751117354719185504644902636551281622882446257591633303910722538374218214088350865739177150968288747826569959957449066175834413752239709683408005355984917541738188399944697486762655165827658483588453142775687900290951702835297163445621296404352311760066510124120065975585127617858382920419748442360800719304576189323492292796501987518721272675079812554709589045563579212210333466974992356302549478024901141952123828153091140790738602515227429958180724716259166854513331239480494707911915326734302824418604142636395480004480026704962482017928964766975831832713142517029692348896276684403232609275249603579964692565049368183609003238092934595889706953653494060340216654437558900456328822505452556405644824651518754711962184439658253375438856909411303150952617937800297412076651479394259029896959469955657612186561967337862362561252163208628692221032748892186543648022967807057656151446320469279068212073883778142335628236089632080682224680122482611771858963814091839036736722208883215137556003727983940041529700287830766709444745601345564172543709069793961225714298946715435784687886144458123145935719849225284716050492212424701412147805734551050080190869960330276347870810817545011930714122339086639383395294257869050764310063835198343893415961318543475464955697810382930971646514384070070736041123735998434522516105070270562352660127648483084076118301305279320542746286540360367453286510570658748822569815793678976697422057505968344086973502014102067235850200724522563265134105592401902742162484391403599895353945909440704691209140938700126456001623742880210927645793106579229552498872758461012648369998922569596881592056001016552563756785667227966198857827948488558343975187445455129656344348039664205579829368043522027709842942325330225763418070394769941597915945300697521482933665556615678736400536665641654732170439035213295435291694145990416087532018683793702348886894791510716378529023452924407736594956305100742108714261349745956151384987137570471017879573104229690666702144986374645952808243694457897723300487647652413390759204340196340391147320233807150952220106825634274716460243354400515212669324934196739770415956837535551667302739007497297363549645332888698440611964961627734495182736955882207573551766515898551909866653935494810688732068599075407923424023009259007017319603622547564789406475483466477604114632339056513433068449539790709030234604614709616968868850140834704054607429586991382966824681857103188790652870366508324319744047718556789348230894310682870272280973624809399627060747264553992539944280811373694338872940630792615959954626246297070625948455690347119729964090894180595343932512362355081349490043642785271383159125689892951964272875739469142725343669415323610045373048819855170659412173524625895487301676002988659257866285612496655235338294287854253404830833070165372285635591525347844598183134112900199920598135220511733658564078264849427644113763938669248031183644536985891754426473998822846218449008777697763127957226726555625962825427653183001340709223343657791601280931794017185985999338492354956400570995585611349802524990669842330173503580440811685526531170995708994273287092584878944364600504108922669178352587078595129834417295351953788553457374260859029081765155780390594640873506123226112009373108048548526357228257682034160504846627750450031262008007998049254853469414697751649327095049346393824322271885159740547021482897111777923761225788734771881968254629812686858170507402725502633290449762778944236216741191862694396506715157795867564823993917604260176338704549901761436412046921823707648878341968968611815581587360629386038101712158552726683008238340465647588040513808016336388742163714064354955618689641122821407533026551004241048967835285882902436709048871181909094945331442182876618103100735477054981596807720094746961343609286148494178501718077930681085469000944589952794243981392135055864221964834915126390128038320010977386806628779239718014613432445726400973742570073592100315415089367930081699805365202760072774967458400283624053460372634165542590276018348403068113818551059797056640075094260878857357960373245141467867036880988060971642584975951380693094494015154222219432913021739125383559150310033303251117491569691745027149433151558854039221640972291011290355218157628232831823425483261119128009282525619020526301639114772473314857391077758744253876117465786711694147764214411112635835538713610110232679877564102468240322648346417663698066378576813492045302240819727856471983963087815432211669122464159117767322532643356861461865452226812688726844596844241610785401676814208088502800541436131462308210259417375623899420757136275167457318918945628352570441335437585753426986994725470316566139919996826282472706413362221789239031760854289437339356188916512504244040089527198378738648058472689546243882343751788520143956005710481194988423906061369573423155907967034614914344788636041031823507365027785908975782727313050488939890099239135033732508559826558670892426124294736701939077271307068691709264625484232407485503660801360466895118400936686095463250021458529309500009071510582362672932645373821049387249966993394246855164832611341461106802674466373343753407642940266829738652209357016263846485285149036293201991996882851718395366913452224447080459239660281715655156566611135982311225062890585491450971575539002439315351909021071194573002438801766150352708626025378817975194780610137150044899172100222013350131060163915415895780371177927752259787428919179155224171895853616805947412341933984202187456492564434623925319531351033114763949119950728584306583619353693296992898379149419394060857248639688369032655643642166442576079147108699843157337496488352927693282207629472823815374099615455987982598910937171262182830258481123890119682214294576675807186538065064870261338928229949725745303328389638184394477077940228435988341003583854238973542439564755568409522484455413923941000162076936368467764130178196593799715574685419463348937484391297423914336593604100352343777065888677811394986164787471407932638587386247328896456435987746676384794665040741118256583788784548581489629612739984134427260860618724554523606431537101127468097787044640947582803487697589483282412392929605829486191966709189580898332012103184303401284951162035342801441276172858302435598300320420245120728725355811958401491809692533950757784000674655260314461670508276827722235341911026341631571474061238504258459884199076112872580591139356896014316682831763235673254170734208173322304629879928049085140947903688786878949305469557030726190095020764334933591060245450864536289354568629585313153371838682656178622736371697577418302398600659148161640494496501173213138957470620884748023653710311508984279927544268532779743113951435741722197597993596852522857452637962896126915723579866205734083757668738842664059909935050008133754324546359675048442352848747014435454195762584735642161981340734685411176688311865448937769795665172796623267148103386439137518659467300244345005449953997423723287124948347060440634716063258306498297955101095418362350303094530973358344628394763047756450150085075789495489313939448992161255255977014368589435858775263796255970816776438001254365023714127834679261019955852247172201777237004178084194239487254068015560359983905489857235467456423905858502167190313952629445543913166313453089390620467843877850542393905247313620129476918749751910114723152893267725339181466073000890277689631148109022097245207591672970078505807171863810549679731001678708506942070922329080703832634534520380278609905569001341371823683709919495164896007550493412678764367463849020639640197666855923356546391383631857456981471962108410809618846054560390384553437291414465134749407848844237721751543342603066988317683310011331086904219390310801437843341513709243530136776310849135161564226984750743032971674696406665315270353254671126675224605511995818319637637076179919192035795820075956053023462677579439363074630569010801149427141009391369138107258137813578940055995001835425118417213605572752210352680373572652792241737360575112788721819084490061780138897107708229310027976659358387589093956881485602632243937265624727760378908144588378550197028437793624078250527048758164703245812908783952324532378960298416692254896497156069811921865849267704039564812781021799132174163058105545988013004845629976511212415363745150056350701278159267142413421033015661653560247338078430286552572227530499988370153487930080626018096238151613669033411113865385109193673938352293458883225508870645075394739520439680790670868064450969865488016828743437861264538158342807530618454859037982179945996811544197425363443996029025100158882721647450068207041937615845471231834600726293395505482395571372568402322682130124767945226448209102356477527230820810635188991526928891084555711266039650343978962782500161101532351605196559042118449499077899920073294769058685778787209829013529566139788848605097860859570177312981553149516814671769597609942100361835591387778176984587581044662839988060061622984861693533738657877359833616133841338536842119789389001852956919678045544828584837011709672125353387586215823101331038776682721157269495181795897546939926421979155233857662316762754757035469941489290413018638611943919628388705436777432242768091323654494853667680000010652624854730558615989991401707698385483188750142938908995068545307651168033373222651756622075269517914422528081651716677667279303548515420402381746089232839170327542575086765511785939500279338959205766827896776445318404041855401043513483895312013263783692835808271937831265496174599705674507183320650345566440344904536275600112501843356073612227659492783937064784264567633881880756561216896050416113903906396016202215368494109260538768871483798955999911209916464644119185682770045742434340216722764455893301277815868695250694993646101756850601671453543158148010545886056455013320375864548584032402987170934809105562116715468484778039447569798042631809917564228098739987669732376957370158080682290459921236616890259627304306793165311494017647376938735140933618332161428021497633991898354848756252987524238730775595559554651963944018218409984124898262367377146722606163364329640633572810707887581640438148501884114318859882769449011932129682715888413386943468285900666408063140777577257056307294004929403024204984165654797367054855804458657202276378404668233798528271057843197535417950113472736257740802134768260450228515797957976474670228409995616015691089038458245026792659420555039587922981852648007068376504183656209455543461351341525700659748819163413595567196496540321872716026485930490397874895890661272507948282769389535217536218507962977851461884327192232238101587444505286652380225328438913752738458923844225354726530981715784478342158223270206902872323300538621634798850946954720047952311201504329322662827276321779088400878614802214753765781058197022263097174950721272484794781695729614236585957820908307332335603484653187302930266596450137183754288975579714499246540386817992138934692447419850973346267933210726868707680626399193619650440995421676278409146698569257150743157407938053239252394775574415918458215625181921552337096074833292349210345146264374498055961033079941453477845746999921285999993996122816152193148887693880222810830019860165494165426169685867883726095877456761825072759929508931805218729246108676399589161458550583972742098090978172932393010676638682404011130402470073508578287246271349463685318154696904669686939254725194139929146524238577625500474852954768147954670070503479995888676950161249722820403039954632788306959762493615101024365553522306906129493885990157346610237122354789112925476961760050479749280607212680392269110277722610254414922157650450812067717357120271802429681062037765788371669091094180744878140490755178203856539099104775941413215432844062503018027571696508209642734841469572639788425600845312140659358090412711359200419759851362547961606322887361813673732445060792441176399759746193835845749159880976674470930065463424234606342374746660804317012600520559284936959414340814685298150539471789004518357551541252235905906872648786357525419112888773717663748602766063496035367947026923229718683277173932361920077745221262475186983349515101986426988784717193966497690708252174233656627259284406204302141137199227852699846988477023238238400556555178890876613601304770984386116870523105531491625172837327286760072481729876375698163354150746088386636406934704372066886512756882661497307886570156850169186474885416791545965072342877306998537139043002665307839877638503238182155355973235306860430106757608389086270498418885951380910304235957824951439885901131858358406674723702971497850841458530857813391562707603563907639473114554958322669457024941398316343323789759556808568362972538679132750555425244919435891284050452269538121791319145135009938463117740179715122837854601160359554028644059024964669307077690554810288502080858008781157738171917417760173307385547580060560143377432990127286772530431825197579167929699650414607066457125888346979796429316229655201687973000356463045793088403274807718115553309098870255052076804630346086581653948769519600440848206596737947316808641564565053004988161649057883115434548505266006982309315777650037807046612647060214575057932709620478256152471459189652236083966456241051955105223572397395128818164059785914279148165426328920042816091369377737222999833270820829699557377273756676155271139225880552018988762011416800546873655806334716037342917039079863965229613128017826797172898229360702880690877686605932527463784053976918480820410219447197138692560841624511239806201131845412447820501107987607171556831540788654390412108730324020106853419472304766667217498698685470767812051247367924791931508564447753798537997322344561227858432968466475133365736923872014647236794278700425032555899268843495928761240075587569464137056251400117971331662071537154360068764773186755871487839890810742953094106059694431584775397009439883949144323536685392099468796450665339857388878661476294434140104988899316005120767810358861166020296119363968213496075011164983278563531614516845769568710900299976984126326650234771672865737857908574664607722834154031144152941880478254387617707904300015669867767957609099669360755949651527363498118964130433116627747123388174060373174397054067031096767657486953587896700319258662594105105335843846560233917967492678447637084749783336555790073841914731988627135259546251816043422537299628632674968240580602964211463864368642247248872834341704415734824818333016405669596688667695634914163284264149745333499994800026699875888159350735781519588990053951208535103572613736403436753471410483601754648830040784641674521673719048310967671134434948192626811107399482506073949507350316901973185211955263563258433909982249862406703107683184466072912487475403161796994113973877658998685541703188477886759290260700432126661791922352093822787888098863359911608192353555704646349113208591897961327913197564909760001399623444553501434642686046449586247690943470482932941404111465409239883444351591332010773944111840741076849810663472410482393582740194493566516108846312567852977697346843030614624180358529331597345830384554103370109167677637427621021370135485445092630719011473184857492331816720721372793556795284439254815609137281284063330393735624200160456645574145881660521666087387480472433912129558777639069690370788285277538940524607584962315743691711317613478388271941686066257210368513215664780014767523103935786068961112599602818393095487090590738613519145918195102973278755710497290114871718971800469616977700179139196137914171627070189584692143436967629274591099400600849835684252019155937037010110497473394938778859894174330317853487076032219829705797511914405109942358830345463534923498268836240433272674155403016195056806541809394099820206099941402168909007082133072308966211977553066591881411915778362729274615618571037217247100952142369648308641025928874579993223749551912219519034244523075351338068568073544649951272031744871954039761073080602699062580760202927314552520780799141842906388443734996814582733720726639176702011830046481900024130835088465841521489912761065137415394356572113903285749187690944137020905170314877734616528798482353382972601361109845148418238081205409961252745808810994869722161285248974255555160763716750548961730168096138038119143611439921063800508321409876045993093248510251682944672606661381517457125597549535802399831469822036133808284993567055755247129027453977621404931820146580080215665360677655087838043041343105918046068008345911366408348874080057412725867047922583191274157390809143831384564241509408491339180968402511639919368532255573389669537490266209232613188558915808324555719484538756287861288590041060060737465014026278240273469625282171749415823317492396835301361786536737606421667781377399510065895288774276626368418306801908046098498094697636673356622829151323527888061577682781595886691802389403330764419124034120223163685778603572769415417788264352381319050280870185750470463129333537572853866058889045831114507739429352019943219711716422350056440429798920815943071670198574692738486538334361457946341759225738985880016980147574205429958012429581054565108310462972829375841611625325625165724980784920998979906200359365099347215829651");
	public static boolean periodRounding = true;

	//above since its too big is a big value for pi, 25000 digits or so for use in large numbers for presion. 
	static Double[] letval = new Double[]{ /*these are the values that are used for the molar masses, in the order of the lists below */
(double)1.00797,
(double)4.0026,
(double)6.941,
(double)9.01218,
(double)10.81,
(double)12.011,
(double)14.0067,
(double)15.9994,
(double)18.998403,
(double)20.179,
(double)22.98977,
(double)24.305,
(double)26.98154,
(double)28.0855,
(double)30.97376,
(double)32.06,
(double)35.453,
(double)39.0983,
(double)39.948,
(double)40.08,
(double)44.9559,
(double)47.9,
(double)50.9415,
(double)51.996,
(double)54.938,
(double)55.847,
(double)58.7,
(double)58.9332,
(double)63.546,
(double)65.38,
(double)69.72,
(double)72.59,
(double)74.9216,
(double)78.96,
(double)79.904,
(double)83.8,
(double)85.4678,
(double)87.62,
(double)88.9059,
(double)91.22,
(double)92.9064,
(double)95.94,
(double)-98,
(double)101.07,
(double)102.9055,
(double)106.4,
(double)107.868,
(double)112.41,
(double)114.82,
(double)118.69,
(double)121.75,
(double)126.9045,
(double)127.6,
(double)131.3,
(double)132.9054,
(double)137.33,
(double)138.9055,
(double)140.12,
(double)140.9077,
(double)144.24,
(double)-145,
(double)150.4,
(double)151.96,
(double)157.25,
(double)158.9254,
(double)162.5,
(double)164.9304,
(double)167.26,
(double)168.9342,
(double)173.04,
(double)174.967,
(double)178.49,
(double)180.9479,
(double)183.85,
(double)186.207,
(double)190.2,
(double)192.22,
(double)195.09,
(double)196.9665,
(double)200.59,
(double)204.37,
(double)207.2,
(double)208.9804,
(double)209,
(double)210,
(double)222,
(double)223,
(double)226.0254,
(double)227.0278,
(double)231.0359,
(double)232.0381,
(double)237.0482,
(double)238.029,};

static String[] wor = new String[]{ /*these are the string full names for the values above in the molar mass hashmap */
"Hydrogen",
"Helium",
"Lithium",
"Beryllium",
"Boron",
"Carbon",
"Nitrogen",
"Oxygen",
"Fluorine",
"Neon",
"Sodium",
"Magnesium",
"Aluminum",
"Silicon",
"Phosphorus",
"Sulfur",
"Chlorine",
"Potassium",
"Argon",
"Calcium",
"Scandium",
"Titanium",
"Vanadium",
"Chromium",
"Manganese",
"Iron",
"Nickel",
"Cobalt",
"Copper",
"Zinc",
"Gallium",
"Germanium",
"Arsenic",
"Selenium",
"Bromine",
"Krypton",
"Rubidium",
"Strontium",
"Yttrium",
"Zirconium",
"Niobium",
"Molybdenum",
"Technetium",
"Ruthenium",
"Rhodium",
"Palladium",
"Silver",
"Cadmium",
"Indium",
"Tin",
"Antimony",
"Iodine",
"Tellurium",
"Xenon",
"Cesium",
"Barium",
"Lanthanum",
"Cerium",
"Praseodymium",
"Neodymium",
"Promethium",
"Samarium",
"Europium",
"Gadolinium",
"Terbium",
"Dysprosium",
"Holmium",
"Erbium",
"Thulium",
"Ytterbium",
"Lutetium",
"Hafnium",
"Tantalum",
"Tungsten",
"Rhenium",
"Osmium",
"Iridium",
"Platinum",
"Gold",
"Mercury",
"Thallium",
"Lead",
"Bismuth",
"Polonium",
"Astatine",
"Radon",
"Francium",
"Radium",
"Actinium",
"Protactinium",
"Thorium",
"Neptunium",
"Uranium",
};

static String[] worNC = new String[]{ /*these are the string full names for the values above in the molar mass hashmap */
"hydrogen",
"helium",
"lithium",
"beryllium",
"boron",
"carbon",
"nitrogen",
"oxygen",
"fluorine",
"neon",
"sodium",
"magnesium",
"aluminum",
"silicon",
"phosphorus",
"sulfur",
"chlorine",
"potassium",
"argon",
"calcium",
"scandium",
"titanium",
"vanadium",
"chromium",
"manganese",
"iron",
"nickel",
"cobalt",
"copper",
"zinc",
"gallium",
"germanium",
"arsenic",
"selenium",
"bromine",
"krypton",
"rubidium",
"strontium",
"yttrium",
"zirconium",
"niobium",
"molybdenum",
"technetium",
"ruthenium",
"rhodium",
"palladium",
"silver",
"cadmium",
"indium",
"tin",
"antimony",
"iodine",
"tellurium",
"xenon",
"cesium",
"barium",
"lanthanum",
"cerium",
"praseodymium",
"neodymium",
"promethium",
"samarium",
"europium",
"gadolinium",
"terbium",
"dysprosium",
"holmium",
"erbium",
"thulium",
"ytterbium",
"lutetium",
"hafnium",
"tantalum",
"tungsten",
"rhenium",
"osmium",
"iridium",
"platinum",
"gold",
"mercury",
"thallium",
"lead",
"bismuth",
"polonium",
"astatine",
"radon",
"francium",
"radium",
"actinium",
"protactinium",
"thorium",
"neptunium",
"uranium",
};


static String[] let = new String[]{ /*these are the abreiviated letters for the molar masses.  */
"H",
"He",
"Li",
"Be",
"B",
"C",
"N",
"O",
"F",
"Ne",
"Na",
"Mg",
"Al",
"Si",
"P",
"S",
"Cl",
"K",
"Ar",
"Ca",
"Sc",
"Ti",
"V",
"Cr",
"Mn",
"Fe",
"Ni",
"Co",
"Cu",
"Zn",
"Ga",
"Ge",
"As",
"Se",
"Br",
"Kr",
"Rb",
"Sr",
"Y",
"Zr",
"Nb",
"Mo",
"Tc",
"Ru",
"Rh",
"Pd",
"Ag",
"Cd",
"In",
"Sn",
"Sb",
"I",
"Te",
"Xe",
"Cs",
"Ba",
"La",
"Ce",
"Pr",
"Nd",
"Pm",
"Sm",
"Eu",
"Gd",
"Tb",
"Dy",
"Ho",
"Er",
"Tm",
"Yb",
"Lu",
"Hf",
"Ta",
"W",
"Re",
"Os",
"Ir",
"Pt",
"Au",
"Hg",
"Tl",
"Pb",
"Bi",
"Po",
"At",
"Rn",
"Fr",
"Ra",
"Ac",
"Pa",
"Th",
"Np",
"U",
};
//this constructor is for adding values to the lists for e power taylor. 
public math(String name, BigDecimal B)
{
	if(name.equals("fac"))
	{
		Factorialed.add(B);
		if(dev == true)
		{
			//println("factorial now in math = " + B,0);
		}
	}
	if(name.equals("pow"))
	{
		powered.add(B);
	}
	
}
public static boolean lastinnew = false;
static String lastInput = "";
public math(String name) //for taking in eqations from text box 
{
	if(dev == true)
	{
		println("lastinnew before is " + lastinnew,0);
	}
	lastinnew = true;
	lastInput = name;
	if(dev == true)
	{
		println("constructor called and string transfered, string = " + lastInput + " and the boolean is = " + lastinnew,0);
	}
}

static HashMap<String, Double> chemMolar = new HashMap<String, Double>(){{ /*this is a hasmap of all of the molar masses, it takes the arrays and adds them */
	
		for(int i = 0; i < let.length; i++)
		{
			put(let[i],letval[i]);
		}	
		for(int i = 0; i < let.length; i++)
		{
			put(wor[i],letval[i]);
		}	
		for(int i = 0; i < let.length; i++)
		{
			put(worNC[i],letval[i]);
		}

	}};

	static HashMap<String, Double> specialNum = new HashMap<String, Double>(){{ /*these are all the special numbers that can be substituted for numbers, add all special numbers here */
		put("e",2.718281828459045);
		put("pi",3.1415926535897932);
		put("avo",(6.02214076e+23));
		put("avogadro",(6.02214076e+23));
		put("avogadro's",(6.02214076e+23));
		put("avogadro'snumber",(6.02214076e+23));
		put("avogadro'snum",(6.02214076e+23));
		put("avonum",(6.02214076e+23));
		put("π",3.1415926535897932);
		put("Krish'sFav",69420D);
		put("Krish'sFav",69420D);
		put("Krish'sFav",69420D);
		//Chem molar masses
		putAll(chemMolar);
	}};
	
	//all operations and their corosponding number (made for final output thing code.)
	static HashMap<String, Integer> operations = new HashMap<String, Integer>(){{
		put("+", 0);
		put("-", 1);
		put("x", 2);
		put("/", 3);
		put("^", 4);
		put("power", 4);
		put("pow", 4);
		put("powerof", 4);
		put("root", 5);
		put("√", 5);
		put("!",6);
		put("factorial",6);
		put("%",7);
		put("remainder",7);
		put("sin",8);
		put("cosin",9);
		put("tangent",10);
		put("secant",12);
		put("cosecant",11);
		put("cotangent",13);
		put("Sin",8);
		put("Cosin",9);
		put("Tangent",10);
		put("Secant",12);
		put("Cosecant",11);
		put("Cotangent",13);
		put("sin",8);
		put("cos",9);
		put("tan",10);
		put("sec",12);
		put("csc",11);
		put("cot",13);
		put("ln",14);
		put("log",15);
		put("toRad",16);
		put("toRadians",16);
		put("torad",16);
		put("toradians",16);
		put("asin",17);
		put("acos",18);
		put("atan",19);
		put("xtoPol",20);
		put("ytoPol",21);
		put("toDeg",22);
		put("toDegrees",22);
		put("todegrees",22);
		put("todeg",22);
		put("ToDegrees",22);
		put("Todegrees",22);
		put("todegrees",22);
		put("ToDeg",22);
		
	}};
	static HashMap<String,BigDecimal> bigspecial = new HashMap<String, BigDecimal>()
	{{
		
	}};
	public static void information() //this just displays some information when called, is used for the info page. 
	{
		println(" \n \n \n \n Calculator information:",2);
		println("basic functionality can be done by default, inputing numbers and oporations with spaces inbetween, for example 1 + 1. \n this will then give the answer to the question back along with the modified input.",2);
		println("if your input has charactors that don't make sense or aren't recognized the calculator will attempt to continue anyway and will tell you where the charactor was. \n If two numbers are next to another without an oporater the defeault is multiplication.\n pharenthesis work just make sure there are spaces between, it will attempt to fix it if you screw up the pharenthesis. \n \n there are then a few special inputs possible designated with keywords written first. \n the first of this is Taylor, the key word Taylor enters the Taylor series mode which can calculate a few speical things like e ^ x and pi. \n the syntax for Taylor is, Taylor (the amount of terms in the polynomial) and finally what it is like e power (some power)",2);
		println("\n taylor calculations available are all trig function, e, root, pi, and bcalc for just the calcualtions of big decimals. if you put b after the pi calculation like pi b , this uses eulers identity to split it into arctan(0.5) and arctan(1/3)",2);
		println("\n input Fib to enter an A B Fibanochi sequence maker, after Fib put the about of times it should do, up to like 40 or something where it overloads the string",2);
		println("\n input root2 after Taylor and its terms to calculate root 2, this works normally on its own or if you put c after it tests it by multipling it by itself to see how many 0's after 2 are present",2);
		println("\n after the first calculation if you decide to repeat you can enter y when prompted and continue entering equations until you type exit when it stops. \n each answer can then be used as an input by entering ans(plus the number of the calculation put above the answer) one example might be ans1 . \n Special calculations like Taylor calculations can be used for calculations with bans(the number of the calculation) but if in doubles will be rounded to doubles",2);
		println("\n \n finally enter debug logs to get increase infomration about the calculations like how far along a calculation is and when is being done",2);
		println("\n \n the calculator can be cosmetically changed by picking one of the theme buttons at the bottom, or by typing it into the typer \n to cosmetically change it you first must put in the keyword command or comm as the first word, then after a space write weather you wat to change the foreground or background by either typing foregroundcolor or backgroundcolor (forecolor and backcolor and some others also work.) \n then after a space type a color, this can either be 3 seperate words for rgb values, 3 values seperated with a space, a hexcode or the word of the color.",2);

		println("to enable debug logs enter y",2);
	}

	static public String call() throws IOException {
		BufferedReader br = new BufferedReader(
			new InputStreamReader(System.in));
		if(dev == true)
		{
			println("special wait input called.",0);
		}	
		String input;
		do {
		  //println("enter equation: ",2);
		  try {
			// wait until we have data to complete a readLine()
			if(dev == true)
				{ //print("waiting for input outside, boolean is = " + lastinnew,0);
				}
			while (!br.ready()  && lastinnew == false/*  ADD SHUTDOWN CHECK(S) HERE */) {
			  Thread.sleep(200);
			  if(dev == true)
				{//print("waiting for input inside and boolean is = " + lastinnew,0);
				}
			}
			if(br.ready())
			{
			input = br.readLine();
			} else if(lastinnew == true)
			{
				input = lastInput;
				if(dev == true)
				{println("input is updated in try",0);}
			}else {
				println("Idk why this stopped really ",2);
				input = "error or something idk";
			}
		  } catch (InterruptedException e) {
			if(dev == true)
			{
				println("input in text box used instead",0);
			}
			//lastinnew = false;
			return lastInput;
		  }
		  if(lastinnew == true)
			{
				input = lastInput;
				if(dev == true)
				{println("input is updated",0);}
			}
		} while ("".equals(input));
		if(dev == true)
		{
			println("this thing at end of call() called",0);
		}
		lastinnew =false;
		return input;
	}


	static boolean hasin = false;
	public static String EqInputGet()
	{
		String nextin = "";
		try
		{
		nextin = call();
		}catch (Exception e){ if(dev == true) {print("whatever the hell this is it happened",0); nextin = null;}}
		//lastinnew = false;
		/*while(SwingApplication.inputdone == false )
		{
			if(dev == true)
			{
				println("waiting for input lastinnew = " + lastinnew,0);
			}
		}*/
		//SwingApplication.inputdone = false;
		nextin = lastInput;
		
		//Scanner scan = new Scanner(System.in);
		//String stater = scan.nextLine();
		//nextin = stater;
			if(isExit(nextin))
			{
				repeat = false;
			}
		return nextin;
		
	}
	static boolean repeat = false;
	public static void main(String[] args) // this is the main method thats called from the begining 
	{
		

		try {

            UIManager.setLookAndFeel(
                UIManager.getCrossPlatformLookAndFeelClassName());

        } catch (Exception e) {
			if(dev == true)
			{
				println("idk why this is excepted but yeah",0);
			}
		 }

        //Create the top-level container and add contents to it.
        JFrame frame = new JFrame("Calculator");
        SwingApplication app = new SwingApplication();
        Component contents = app.createComponents();
        frame.getContentPane().add(contents, BorderLayout.CENTER);

        //Finish setting up the frame, and show it.
        frame.addWindowListener(new WindowAdapter() {

            public void windowClosing(WindowEvent e) {

                System.exit(0);

            }

        });
        frame.pack();
        frame.setVisible(true);


		println(" Welcome to my calculator",2);
		println("to enter info/settings enter y, enter anything else to continue to calculator",2);
		String stater = EqInputGet();
		if(dev == true)
		{
			println("stating is " + stater,0);
			println("the if is " + stater.equals("y"),0);
		}
		if(stater.equals("y"))
		{
			information();
			String devs = EqInputGet();
			if(devs.equals("y"))
			{
				dev = true;
			}
			print("continuing to calculator",2);
				if(dev == true)
				{
					//println(specialNum.get("avo") + "did",0);
				}
				if(args.length > 0)
			{
				calcstart(args);
			}else 
			{
				println("No inputs detected, answer will there for be zero.",2);
				String[] a = new String[1];
				a[0] = "0";
				calcstart(a);
			}
		}else
		{
			if(args.length > 0)
			{
				calcstart(args);
			}else 
			{
				println("No inputs detected, answer will there for be zero.",2);
				String[] a = new String[1];
				a[0] = "0";
				calcstart(a);
			}
		}
			amountre ++;
			repeat = false;
		println("repeat? if you click yes it'll keep repeating unless you enter exit",2);
		String re = EqInputGet();
		if(isYes(re))
		{
			repeat = true;
		}	
		while(repeat == true)
		{
			MaxPrec = SwingApplication.getvalue();
				Taylorchecked = SwingApplication.Taylorcheck();
			MaxPrec = SwingApplication.getvalue();
			if(dev == true)
			{
				println("maxprec = " + MaxPrec,0);
			}
			println("enter equation: ",2);
			String nextin = EqInputGet();
				String[] nextLIn = stringTArray(nextin);
				//calcstart(nextLIn);
				if(nextLIn.length > 0)
				{
					calcstart(nextLIn);
				}else 
				{
				println("No inputs detected, answer will there for be zero.",2);
				String[] a = new String[1];
				a[0] = "0";
				calcstart(a);
				}
			amountre ++;
		}
	}
	public static boolean isExit(String args) /* this just returns whether the string is some variation of exit  */
	{
		boolean re = false;
		if ( args.equals("Exit") || args.equals("exit") || args.equals("EXIT") || args.equals("Cancel") || args.equals("cancel") || args.equals("leave") || args.equals("Leave"))
		{
			re = true;
		}
		return re;
	}

	public static boolean isYes(String args) // this is just a method that returns if the string is a yes 
	{
		boolean re = false;
		if (args.equals("Yes") || args.equals("yes") || args.equals("Y") || args.equals("y") || args.equals("YES") || args.equals("YE") || args.equals("YEs") || args.equals("yES") || args.equals("yeS") || args.equals("yEs") )
		{
			re = true;
		}
		return re;
	}

	public static String[] stringTArray(String args) // this turns a string to an array, it uses spaces, does nothing about feeding it. 
	{
		List<String> reL = new ArrayList<String>();
		int currenti = 0;
		while (currenti < args.length())
		{
			String currentP = "";
			boolean isS = false;
			while(isS == false && currenti < args.length())
			{
				if(args.charAt(currenti) == ' ')
				{
					isS = true;
					
				}else
				{
					currentP = currentP + args.charAt(currenti);
			
				}
				currenti++;
				
			}
			reL.add(currentP);
			isS = false;
		}
		String[] re = new String[reL.size()];
		for(int i = 0; i < reL.size(); i++)
		{
			re[i] = reL.get(i);
		}
		return re;
	}

	public static void calcstart(String[] args)	//starts the calculations, prepares for the final calc method 
	{
		print("calcStart started",0);
		MaxPrec = SwingApplication.getvalue();
		Taylorchecked = SwingApplication.Taylorcheck();
		if(dev == true)
		{
			println("Taylorchecked = " + Taylorchecked,0);
		}
		if(!(args[0].equals("Taylor") || args[0].equals("taylor")) && !args[0].equals("Fib") && !(args[0].equals("Command")||args[0].equals("command")||args[0].equals("comm") || args[0].equals("Comm")))
		{
				incurrent = 0;
			opast = false;
			
			List<String> Lmodargs = seeifnot(args); //this modifies the args
			String[] modargs = new String[Lmodargs.size()];
			for(int i = 0; i < Lmodargs.size(); i++)
			{
				modargs[i] = Lmodargs.get(i);
			}
			String[] pArgsT = parenthesisCount(modargs);
			List<String> pArgs = new ArrayList<String>(pArgsT.length);
			Collections.addAll(pArgs, pArgsT);	
			List<Integer> numbersIn = findnums(pArgs); //this is index of modargs of numbers
			List<Integer> operationsIn = findop(pArgs);//this is index of modargs of oporations	

				double finalout = finalcalcS(numbersIn, operationsIn, pArgs);
				specialNum.put("ans" + amountre, finalout);
				println("\n Answer num " + amountre + " :",1);
				println("" + pArgs +"="+ finalout + "\n",1);
			}else if ((args[0].equals("Taylor") || args[0].equals("taylor"))&& args.length > 0)
				{
					taylorSpliter(args);
			}else if (args[0].equals("Fib") && args.length > 0)
			{
				String a = FibStart(args);
				//println("\n fibanoci done = \n" + a,1);
				
			}else if(args[0].equals("Command") || args[0].equals("command") || args[0].equals("comm") || args[0].equals("Comm"))
			{
				println("command recognized, activing rest of stuff",0);
				String[] commandin = new String[args.length - 1];
				for(int i=0; i < (args.length - 1);i++)
				{		
						commandin[i] = args[i + 1];
				}
				commandstuff(commandin);
			}else
			{
				println("feature not yet implimented or detected or something. idk just didn't work",2);
			}
			lastinnew = false;
			SwingApplication.progressUpdate(0);
			if(dev == true)
			{
				println("progress bar reset",0);
			}
		
	} 
	public static void taylorSpliter(String[] args) //this is called in the calc start and it handles all the logic and division between taylor series functions.
	{
		long time = System.currentTimeMillis();
					BigDecimal outP = new BigDecimal(0);
							if(dev == true)
							{
								println("for about to happen in root2",0);
							}
					if(args[2].equals("e"))
					{
						outP = etaylorcalc(args);

					}else if(args[2].equals("pi"))
					{
						outP = SPitaystart(args);
						
					} else if (args[2].equals("sin"))
				{
					if(isInteger(args[1]))
					{
						double pos = 0;
						BigDecimal posB = new BigDecimal(0);
						posB = TaylorSinPosM(args, "2pi");
						BigDecimal p = SsinTayStart(Integer.parseInt(args[1]), posB);
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println(" \n bans" + bigamount + " = sin taylor series finished \n answer = \n" + p,1);
						outP = p;
					}

				}else if(args[2].equals("cos"))
				{
					double pos = 0;
						BigDecimal posB = new BigDecimal(0);
						posB = TaylorSinPosM(args,"2pi");
						BigDecimal p = ScosTayStart(Integer.parseInt(args[1]), posB);
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println(" \n bans" + bigamount + " = cos taylor series finished \n answer = \n" + p,1);
						outP = p;
				}else if(args[2].equals("tan"))
				{
					double pos = 0;
						BigDecimal posB = new BigDecimal(0);
						posB = TaylorSinPosM(args,"pi");
						BigDecimal s = SsinTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal c = ScosTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal p = s.divide(c, new MathContext(MaxPrec + 5));
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println("\n bans" + bigamount + " = cos taylor series finished \n answer = \n" + p,1);
						outP = p;
				}else if(args[2].equals("cot"))
				{
					double pos = 0;
						BigDecimal posB = new BigDecimal(0);
						posB = TaylorSinPosM(args,"pi");
						BigDecimal s = SsinTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal c = ScosTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal p = c.divide(s, new MathContext(MaxPrec + 5));
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println("\n bans" + bigamount + " = cot taylor series finished \n answer = \n" + p,1);
						outP = p;
				}else if(args[2].equals("sec"))
				{
					double pos = 0;
						BigDecimal posB = new BigDecimal(0);
						posB = TaylorSinPosM(args,"2pi");
						BigDecimal s = ScosTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal p = new BigDecimal(1);
						p = p.divide(s, new MathContext(MaxPrec));
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println("\n bans" + bigamount + " = sec taylor series finished \n answer = \n" + p,1);
						outP = p;
				}else if(args[2].equals("csc"))
				{
						double pos = 0;
					BigDecimal posB = new BigDecimal(0);		
						posB = TaylorSinPosM(args,"2pi");
						BigDecimal s = SsinTayStart(Integer.parseInt(args[1]), posB);
						BigDecimal p = new BigDecimal(1);
						p = p.divide(s, new MathContext(MaxPrec));
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println("\n bans" + bigamount + " = csc taylor series finished \n answer = \n" + p,1);
						outP = p;
				}else if(args[2].equals("root2"))
				{
							if(dev == true)
								{
								println("root function about to start",0);
							}	
					BigDecimal p = root2series(Integer.parseInt(args[1]));
								if(dev == true)
								{
									println("main in root2 ended",0);
								}
						if(args.length >= 4)
						{
						if(args[3].equals("c"))
						{
							p = p.multiply(p);
						}
						}
						if(Taylorchecked == true) p = p.round(new MathContext(MaxPrec));
						println("\n bans" + bigamount + " = root series finished, = \n" + p,1);
						outP = p;
						
				} else if(args[2].equals("BCalc") || args[2].equals("bcalc") || args[2].equals("Bcalc") || args[2].equals("bCalc"))
				{
					BigDecimal p = TaylorSinPosM(args,"a");
					if(dev == true)
					{
						println("\n bcalc completed answer is = " + p,0);
					}
					outP = p;
					
				}else 
				{
					println("nothing found to do so answer will be 0 ",0);
					if(dev == true)
					{
						println("no operation found for taylor",0);
					}
				}
					println("",2);
					SwingApplication.progressUpdate(100);
					println("calculation completed in " + (double) (((double) ( System.currentTimeMillis() -  time )) / 1000),2);
					println("",1);
					for(int i = 0; i < args.length; i++)
					{print(" "+args[i],2);}
					if(dev == true)
					{
						println("before rounding maxPrec = " + MaxPrec + " Taylor Checked = " + Taylorchecked,0);
					}
					if(Taylorchecked == true) outP = outP.round(new MathContext(MaxPrec));
					println("\n bans" + bigamount + " == " + outP,1);
					
					bigspecial.put("bans" + bigamount,outP);
					if(dev == true)
					{
						println("the big special bans" + bigamount + " = " + bigspecial.get("bans" + bigamount),0);
					}
					bigamount++;}


	public static void commandstuff(String[] args)// this is the logic and devision of the command methods
	{
		print("comamnd stuff ran",0);
		String comp = args[0].toLowerCase();
		if( comp.equals("foregroundcolor") || comp.equals("forecolor") || comp.equals("forecol") || comp.equals("foregroundcolorchange") || comp.equals("changeforegroundcolor"))
		{
			foregroundColorer(args);
		}
		else if (comp.equals("backgroundcolor") || comp.equals("backcolor") || comp.equals("backcol") || comp.equals("backgroundcolorchange") || comp.equals("changebackgroundcolor"))
		{
			backgroundColor(args);
		}
	}

	public static void backgroundColor(String[] args)
	{
			println("going into if statments colors bac with value of args[1] as " + args[1],0);
			if(isInteger(args[1]) && Integer.parseInt(args[1]) <= 255)
			{
				if(isInteger(args[2]) && isInteger(args[3]))
				{
					println("about to run set back color with seperate rgbs",0);
					SwingApplication.setColorEl(new Color(Integer.parseInt(args[1]),Integer.parseInt(args[2]),Integer.parseInt(args[3])),SwingApplication.currentbackGet());
					println("should have run set color thingy for back",0);
				}else
				{
					println("failed to find the is integers here code color back 129309",0);
				}
			}else if(args[1].indexOf(",") != -1)
			{
				String[] rgbVals = new String[4];
				int in = 0;
				int fcomma = args[1].indexOf(",");
				rgbVals[0] = args[1].substring(0,fcomma);
				in++;
				rgbVals[3] = "255";
				while(args[1].indexOf(",") != -1)
				{
					int comma = args[1].indexOf(",");
					args[1] = args[1].substring(comma + 1);
					int comma2 = args[1].indexOf(",");
					if(in < 4)
					{
						if(comma2 != -1)
						{
						rgbVals[in] = args[1].substring(0,comma2);
						}else
						{
							rgbVals[in] = args[1].substring(0);
						}
					}
					in++;
				}
				boolean forward = true;
				for(String a : rgbVals)
				{
					if(!isInteger(a))
					{
						forward = false;
					}
				}
				if(forward = true)
				{
					Color incolor = new Color(Integer.parseInt(rgbVals[0]),Integer.parseInt(rgbVals[1]),Integer.parseInt(rgbVals[2]),Integer.parseInt(rgbVals[3]));
					SwingApplication.setColorEl(SwingApplication.currentforeGet(), incolor);
				}else
				{
					println("colors not recognized, please try again",1);
				}

			}else
			{
				try{
				println("where word color value of thing should be ",0);
				Color inputcolor = Color.decode(args[1]);
				SwingApplication.setColorEl(SwingApplication.currentforeGet(),inputcolor);
				}catch(Exception e)
				{
					print("hex code not found for color",0);
					Color color;
					try {
						Field field = Class.forName("java.awt.Color").getField(args[1]);
						color = (Color)field.get(null);
						SwingApplication.setColorEl(SwingApplication.currentforeGet(),color);
					} catch (Exception E) {
						println("color not found in any way, not running statment",0);
					}
				}
				
			}

	}
	
	public static void foregroundColorer(String[] args)
	{
		println("going into if statments colors with value of args[1] as " + args[1],0);
			if(isInteger(args[1]) && Integer.parseInt(args[1]) <= 255)
			{
				if(isInteger(args[2]) && isInteger(args[3]))
				{
					println("about to run set color with seperate rgbs",0);
					SwingApplication.setColorEl(new Color(Integer.parseInt(args[1]),Integer.parseInt(args[2]),Integer.parseInt(args[3])),SwingApplication.currentbackGet());
					println("should have run set color thingy",0);
				}else
				{
					println("failed to find the is integers here code 129309",0);
				}
			}else if(args[1].indexOf(",") != -1)
			{
				String[] rgbVals = new String[4];
				int in = 0;
				int fcomma = args[1].indexOf(",");
				rgbVals[0] = args[1].substring(0,fcomma);
				in++;
				rgbVals[3] = "255";
				while(args[1].indexOf(",") != -1)
				{
					int comma = args[1].indexOf(",");
					args[1] = args[1].substring(comma + 1);
					int comma2 = args[1].indexOf(",");
					if(in < 4)
					{
						if(comma2 != -1)
						{
						rgbVals[in] = args[1].substring(0,comma2);
						}else
						{
							rgbVals[in] = args[1].substring(0);
						}
					}
					in++;
				}
				print("rgbvals found, they are" + rgbVals[0] + " " + rgbVals[1] + " " + rgbVals[2] + " " + rgbVals[3] + " ",0);
				boolean forward = true;
				for(String a : rgbVals)
				{
					if(!isInteger(a))
					{
						forward = false;
					}
				}
				if(forward == true)
				{
					Color incolor = new Color(Integer.parseInt(rgbVals[0]),Integer.parseInt(rgbVals[1]),Integer.parseInt(rgbVals[2]),Integer.parseInt(rgbVals[3]));
					SwingApplication.setColorEl(incolor,SwingApplication.currentbackGet() );
				}

			}else
			{
				try{
					println("where word color value of thing should be ",0);
					Color inputcolor = Color.decode(args[1]);
					SwingApplication.setColorEl(inputcolor,SwingApplication.currentbackGet() );
				}catch(Exception e)
				{
					print("hex code not found for color",0);
					Color color;
					try {
						Field field = Class.forName("java.awt.Color").getField(args[1]);
						color = (Color)field.get(null);
						SwingApplication.setColorEl(color,SwingApplication.currentbackGet());
					} catch (Exception E) {
						print("color not found in any way, not running statment",0);
					}
				}

				
			}
	}

	public static BigDecimal TaylorSinPosM(String[] args, String period) // this does the calculatiosn for the position of a taylor series for sin. it simplifies everything so that equations can be put in for the posistion.  
	{
			List<String> use = new ArrayList<String>();
			for(int i = 3; i < args.length;i++)
			{
				use.add(args[i]);
			}
			use = seeifnot2(use,true);
			if(use.size() <= 0)
			{
				println("no posistion in taylor series found, using 0 instead",2);
				use.add("0");
			}
			if(dev == true)
			{
				println(" taylor sin pos m see if not == \n",0);
				for(int i = 0; i < use.size(); i++)
				{
					println(use.get(i),0);
				}
			}
			double pos = 0;
			BigDecimal posB = new BigDecimal(0);
			BigDecimal posBH = new BigDecimal(0);
			BigDecimal finaly = new BigDecimal(0);
			if(isInteger(use.get(0)))
			{
				finaly = new BigDecimal(Integer.parseInt(use.get(0)));
			}else if(isDouble(use.get(0)))
			{
				if(specialNum.containsKey(use.get(0)))
				{
					finaly = new BigDecimal( specialNum.get(use.get(0)));
				} else if (bigspecial.containsKey(use.get(0)))
				{
					finaly = bigspecial.get(use.get(0));
				}else {
					finaly = new BigDecimal(Double.parseDouble(use.get(0)));
				}
			}else if(use.get(0).equals("piB")||use.get(0).equals("pib")||use.get(0).equals("Bpi")||use.get(0).equals("bpi"))
			{
				finaly = Bpi;
			}else
			{
				finaly = new BigDecimal(0);
				if(dev == true)
				{
					println("unrecognized = " + use.get(0),0);
				}
			}
			posB = finaly;
			int operationsH = 0;
			
			for(int i = 1; i < use.size(); i++)
			{
				if(operations.containsKey(use.get(i)))
				{
					operationsH = operations.get(use.get(i));
				} else if (posB != null)
				{
					if(isInteger(use.get(i)))
					{
						pos = Integer.parseInt(use.get(i));
						posBH = new BigDecimal(pos);
					}else if (isDouble(use.get(i)) && !specialNum.containsKey(use.get(i)) && ! bigspecial.containsKey(use.get(i)))
					{
						pos = Double.parseDouble(use.get(i));
						posBH = new BigDecimal(pos);

					}else if(use.get(i).equals("piB")||use.get(i).equals("pib")||use.get(i).equals("Bpi")||use.get(i).equals("bpi")) 
					{
						posBH = Bpi;
					} else if (specialNum.containsKey(use.get(i)))
					{
						pos = specialNum.get(use.get(i));
						posBH = new BigDecimal(pos);
					}else if ( bigspecial.containsKey(use.get(i)))
					{
						posBH = bigspecial.get(use.get(i));
						if(dev == true)
						{
							println("big special about to be used = " + bigspecial.get(use.get(i)),0);
						}
					}
					
					posB = condensedcalc( posB, posBH, operationsH);
					operationsH = 2;
				}
			}
			finaly = posB;
			if(dev == true)
			{
				println("calculations done, before period correction posistion is =" + finaly,0);
			}
			//next part does period calculations, if a recognized period is entered then it will use it. 
			if(periodRounding == true)
			{
				if(period.equals("pi"))
				{
					
						int temp = (int) finaly.divide(Bpi, new MathContext(10)).doubleValue();
						if(temp > 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.subtract(Bpi); 
							}
						}
						if(temp < 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.add(Bpi); 
							}
						}
					
				}else if(period.equals("2pi"))
				{
					
						int temp = (int) finaly.divide(Bpi.multiply(new BigDecimal(2)), new MathContext(10)).doubleValue();
						if(temp > 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.subtract(Bpi.multiply(new BigDecimal(2))); 
							}
						}
						if(temp < 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.add(Bpi.multiply(new BigDecimal(2))); 
							}
						}
					
				}else if (isDouble(period))
				{
					double Ndouble = 0;
					if(isInteger(period))
					{
						Ndouble = (double) Integer.parseInt(period);

					}else if(isDouble(period))
					{
						Ndouble = 0;
						if(!(specialNum.containsKey(period)) && ! bigspecial.containsKey(period))
						{
							Ndouble = Double.parseDouble(period);
						}else if (specialNum.containsKey(period))
						{
							Ndouble = specialNum.get(period);
						}else if (bigspecial.containsKey(period))
						{
							Ndouble = bigspecial.get(period).doubleValue();
						}else
						{
							println("unrecognized charactor in sin period calculations ",2);
						}
						
					}

					
						int temp = (int) finaly.divide(new BigDecimal(Ndouble), new MathContext(10)).doubleValue();
						if(dev == true)
						{
							println("temp to compare = " + temp,0);
						}
						if(temp > 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.subtract(new BigDecimal(Ndouble)); 
							}
						}
						if(temp < 0)
						{
							for(int i = 0; i < temp; i++)
							{
								finaly = finaly.add(new BigDecimal(Ndouble)); 
							}
						}
					
				}
				if(dev == true)
				{
					println("calculations of posisiton of taylor series done with period correction = " + finaly,0);
				}
			}			
			
			return finaly;
	}
	
	public static BigDecimal condensedcalc(BigDecimal output, BigDecimal Nint, int op) // this is about condensed calculations for big decimals, doesn't have all the equations but it can do them for big decimals 
	{
							if(op == 0)
					{
						output = output.add(Nint);
					}else if(op == 1)
					{
						output = output.add(Nint.multiply( new BigDecimal(-1)));
					}else if(op == 2)
					{
						output = output.multiply(Nint);
					}else if(op == 3)
					{
						if( ! Nint.equals(new BigDecimal(0)))
						{
							output = output.divide(Nint, new MathContext(MaxPrec));
						}else
						{
							println("ERROR",1);

							println("ERROR",1);
							println("ATEMPTED DIVISION BY ZERO",1);
							println("ARE YOU INSANE, THIS COULD DESTABLIZE OUR REALITY",1);
							println("(LARGE EXPLOSION NOICES)",1);
							for(int k = 0;  k < 10; k++)
							{
								println("(LARGE EXPLOSION NOICES)",1);
							}
							System.exit(0);
				
						
				
					}
				{

				}
							
					}else if (op == 4)
					{
						try
						{
							output = output.pow((int) Nint.doubleValue());
						}catch(ArithmeticException e)
						{
							println("\n not you with your " + e + ", I'll let you keep going but like that was stupid.",1);
							println("\n why did you think that would work",1);
							println(" \n dont be stupid",1);
							// output = new BigDecimal();
						}
					}else if (op == 5)
					{
						BigDecimal one = new BigDecimal(1);
						output = output.pow( (int) one.divide(Nint, new MathContext(MaxPrec)).doubleValue());
					}else if (op == 15)
					{
						output = new BigDecimal(Math.log(output.doubleValue()) / Math.log(Nint.doubleValue()));
					}else if (op == 16)
					{
						BigDecimal oneE = new BigDecimal(180);
						output = output.divide(oneE, new MathContext(MaxPrec));
						output = output.multiply(Bpi);
					}else if (op == 22)
					{
						BigDecimal oneE = new BigDecimal(180);
						output = output.divide(Bpi, new MathContext(MaxPrec));
						output = output.multiply(oneE);
						output = output.multiply(Nint);
					
					}else 
					{
						println("unused oporation found in biggy decimal",2);
					}
		return output;
	}


	public static BigDecimal root2series(int terms)
	{
		BigDecimal re = new BigDecimal(1);
		BigDecimal oner = new BigDecimal(1);
		BigDecimal two = new BigDecimal(2);
		if(dev == true)
		{
			println("for about to happen in root2",0);
		}
		for(int i = 0; i < terms; i++)
		{
			re = oner.divide(re, new MathContext(MaxPrec));
			re = re.add(two);
			double a = ((double) i / terms) * 100;
			if(dev == true)
			{
				
		println("root2 series done to "+ a + "%",0);
		
			}
			SwingApplication.progressUpdate(a);
		}
		re = oner.divide(re, new MathContext(MaxPrec));
		re = re.add(oner);
		return re;
	}


	public static BigDecimal SsinTayStart(int terms, BigDecimal pos) // this is the start and kinda parent for the single threaded sin function taylor series. 
	{
		println("SsinTayStart term = " + terms + " posistion = " + pos,2);
		BigDecimal re = pos;
		int realI = 1;
		BigDecimal facB = new BigDecimal(1);
		BigDecimal aH = pos;
		BigDecimal fac = new BigDecimal(1);
		for (int i = 1; i < terms; i++)
		{
			BigDecimal indexe = new BigDecimal(i * 2);
			fac = fac.multiply(indexe);
			indexe = indexe.add(facB);
			fac = fac.multiply(indexe);
			BigDecimal front = new BigDecimal(Math.pow(-1,i));
			BigDecimal a = pos;
			//BigDecimal a = pos;
			//a = a.pow(i * 2 + 1);
			aH = aH.multiply(pos.pow(2));
			a = aH;
			//a = pos.pow(i * 2 + 1);
			a = a.multiply(front);
			a = a.divide(fac, new MathContext(MaxPrec));
			double aaa = (( (double) i / terms) * 100);
			if(dev == true)
			{
				println("Done to amount " + aaa,0);
			}
			SwingApplication.progressUpdate(aaa);
			re = re.add(a);
		}
		return re;
	}
	
	public static BigDecimal ScosTayStart(int terms, BigDecimal pos) // this is the single threaded cosin function taylor series 
	{
		println("ScosTayStart term = " + terms + " posistion = " + pos,2);
		int realI = 1;
		BigDecimal one = new BigDecimal(1);
		BigDecimal None = new BigDecimal(-1);
		BigDecimal aH = one;
		BigDecimal re = one;
		BigDecimal fac = new BigDecimal(1);
		for (int i = 1; i < terms; i++)
		{
			BigDecimal indexe = new BigDecimal(i * 2);
			fac = fac.multiply(indexe);
			indexe = indexe.add(None);
			fac = fac.multiply(indexe);
			BigDecimal front = new BigDecimal(Math.pow(-1,i));
			BigDecimal a = one;
			//a = a.pow(2 * i);
			aH = aH.multiply(pos.pow(2));
			a = aH;
			a = a.multiply(front);
			a = a.divide(fac, new MathContext(MaxPrec));
			double aaa = (( (double) i / terms) * 100);
			if(dev == true)
			{
				println("Cos Done to amount " + aaa,0);
			}
			SwingApplication.progressUpdate(aaa);
			re = re.add(a);
		}
		return re;
	} 
	
	public static String FibStart(String[] Args) // this starts the fibanoci sequence, this just returns a string
	{
		int FibReI = 0;
		FibRePrev = "";
		FibReI = 0;
		String rep = "b";
		String re = "";
		if(isInteger(Args[1]))
		{
			re = FibRe(Integer.parseInt(Args[1]),rep);
		}
		return re;
	}

	static String FibRePrev = "";
	static int FibReI = 0;

	public static String FibRe(int amount, String c) // this is the part that continualy goes in the fibanochi sequence, hence how it works with recursions. 
	{
		String re = c;
		double a = ( (double) FibReI / amount) * 100;
		if(dev == true)
		{
			println("in FibRe",0);
			
			println("amount done = " + a + "%" + "so far = " + FibRePrev + "so far in prev = "+ FibRePrev,0);
			
		}
		SwingApplication.progressUpdate(a);
		if(FibReI == 0)
		{
			FibRePrev = "a";
			FibReI++;
			FibRe(amount,re);
		}else if(FibReI < amount)
		{
			re = re + FibRePrev;
			FibRePrev = c;
			FibReI++;
			if(FibReI < amount)
			{
				FibRe(amount,re);
			}else 
			{
				printFib(re);
			}
			
			
		}
		return re;
		
	}

	public static void printFib(String n) // all this does is print the fibanochi squence 
	{
		println("\n fibanoci done = \n" + n,1);
	}

	//does the taylor calculations with e 
	public static BigDecimal etaylorcalc(String[] Args) // this starts the taylor calculations with e powers
	{
		
		Factorialed.clear();
		powered.clear();
		BigDecimal re = new BigDecimal(0);
		if(Args[2].equals("e") && anyop(Args[3]))
		{
			if(operations.get(Args[3]) == 4 && isInteger(Args[1]))
			{
				
				if(isInteger(Args[4]))
				{
					re = ePowerTay((double) Integer.parseInt(Args[4]),Integer.parseInt(Args[1]));
				}else if(isDouble(Args[4]))
				{
					if(!specialNum.containsKey(Args[4]) && !bigspecial.containsKey(Args[4]))
						re = ePowerTay( Double.parseDouble(Args[4]), Integer.parseInt(Args[1]));
					else if (specialNum.containsKey(Args[4]))
						re = ePowerTay( specialNum.get(Args[4]),Integer.parseInt(Args[1]));
					else if (bigspecial.containsKey(Args[4]))
						re = ePowerTay( bigspecial.get(Args[4]).doubleValue(), Integer.parseInt(Args[1]));
				}
			
			}
		}else
		{
			println("unsupported function 1 = "+ Args[1].equals("e")+ " 2 = " + anyop(Args[2]),2);
		}
		return re;
	}
	
	//does the taylor calculations with e 
	public static BigDecimal SPitaystart(String[] Args) // this is the single threaded pi taylor sieres, calls the SPiTay
	{
		BigDecimal re = new BigDecimal(0);
		if(isInteger(Args[1]))
		{
			
			if(Args[2].equals("pi"))
			{
				if(Args.length > 3)
				{
					if(Args[3].equals("b"))
							re = BSPiTay(Integer.parseInt(Args[1]));
					else
						re = SPiTay(Integer.parseInt(Args[1]),new BigDecimal(1.0));
				}else 
				{
					re = SPiTay(Integer.parseInt(Args[1]),new BigDecimal(1.0));
				}
			}
			
		}else 
		{
			println("unsupported pi taylor function",2);
		}
		return re;
	}
	
	//parent function to switch between multithreaded or single threaded.
	public static BigDecimal ePowerTay(Double x, Integer a) // this only is used to switch between multithreaded and single threaded 
	{
		BigDecimal re = MePowerTay(x,a);
		//BigDecimal re = SePowerTay(x,a);
		return re;
	}
	
	public static BigDecimal SPiTay(Integer a, BigDecimal position) // this is the single threaded taylor function, runns after the above 
	{
		tayPres = a;
		BigDecimal one = new BigDecimal(1);
		BigDecimal b = position;
		BigDecimal l = new BigDecimal(-1);
		BigDecimal front = one;
		BigDecimal dhold = one;
		BigDecimal two = new BigDecimal(2);
		BigDecimal placehold = position;
		for(int i = 1; i < tayPres; i++)
		{
			placehold = placehold.multiply(position.multiply(position));

			dhold = dhold.add(two);
			front = front.multiply(l);
			BigDecimal temp = one.divide(dhold,new MathContext(MaxPrec));
			temp = temp.multiply(placehold);
			b = b.add(temp.multiply(front));
			double aaa = (((double) i) / tayPres) * 100;
			if(dev == true)
			{
				
				println("pi calculation percent = " + aaa + "%",0);
				
				
			}
			SwingApplication.progressUpdate(aaa);
		}
		b = b.multiply(new BigDecimal(4));
		return b;
	}
	
	public static BigDecimal BSPiTay(Integer a) // this is the single threaded taylor function, runns after the above 
	{
		BigDecimal re = new BigDecimal(0);
		BigDecimal one = new BigDecimal(1);
		BigDecimal temp = SPiTay(a, one.divide(new BigDecimal(3), new MathContext(MaxPrec)));
		re =  temp.add(SPiTay(a, new BigDecimal(0.5)));
		//re = re.multiply(new BigDecimal(4));
		return re;
	}
	
	//multithreaded taylor series
	public static BigDecimal MePowerTay(Double x, Integer a) // is the multithreaded e power taylor series  
	{
		tayPres = a;
		epow = x;
		TayFactorial factorialC = new TayFactorial("factorial",(int)((double)tayPres * 1.002),epow,dev);
		factorialC.start();
		TayPow powC = new TayPow ("pow",tayPres,epow,dev);
		powC.start();
		
		
		BigDecimal re = new BigDecimal(1);
		for(int i = 1; i < tayPres; i++)
		{
			while(Factorialed.size() <= 0 || powered.size() <= 0)
			{ 
				double aaa = ((double) i / (double) tayPres) * 100;
					if(dev == true)
					{
						
					println("waiting for threads to finish fac size = "+ Factorialed.size() + "powered size = "+powered.size() + " percent = " + aaa + "%",0);
					
				}
				SwingApplication.progressUpdate(aaa);
			}
		
			BigDecimal xB = new BigDecimal(x);
			BigDecimal adder = powered.get(0);
			BigDecimal divider = Factorialed.get(0);
			adder = adder.divide(divider, new MathContext( MaxPrec ));
			re = re.add(adder);
			Factorialed.remove(0);
			powered.remove(0);
			double aaa = ((double) i / (double) tayPres) * 100;
			if(dev == true)
			{
				
				println("precent done =" + aaa + "%",0);
				
			}
			SwingApplication.progressUpdate(aaa);
		
		}

		return re;
	}
	


	//single threaded calculations for e powers taylor series 
	public static BigDecimal SePowerTay(Double x, Integer a) // this is the single threaded e power taylor calculation. 
	{
		tayPres = a;
		BigDecimal re = new BigDecimal(1);
		for(int i = 1; i < tayPres; i++)
		{
			BigDecimal xB = new BigDecimal(x);
			BigDecimal adder = xB.pow(i);
			BigDecimal divider = bigFactorial(i, 1);
			adder = adder.divide(divider, new MathContext( MaxPrec ));
			re = re.add(adder);
			double aaa = ((double) i / (double) tayPres) * 100;
			if(dev == true)
			{
				
				println("precent done =" + aaa + "%",0);
				
				
			}
			SwingApplication.progressUpdate(aaa);
		
		}
		return re;
	}
	public static BigDecimal Bpow(double x, double p ) // this makes factorials, not much used. stands for big power. 
	{
		BigDecimal re = new BigDecimal(x);
			for(int i = 1; i < p; i++)
		{
			re = re.multiply(re, new MathContext( MaxPrec ));
			
		}
		return re;
	}

	//big factorial caclulates it wwith big numbers
	public static BigDecimal bigFactorial(double output, double Nint) // this is a big factorail function and just takes two double and outputs a big decimal 
	{
		BigDecimal re = new BigDecimal(output);
		for(int i = 1; i < output; i ++)
		{
			BigDecimal m = new BigDecimal(i);
			re = re.multiply(m);
		}

		return re;
	}


	//starts the calc start with modified pharathesis works 
	public static double calcStartP(List<String> args) // this starts a part of the calculatons, for small parts 
	{
		String[] a = new String[args.size()];
		for(int i = 0; i < args.size(); i++)
		{
			a[i] = args.get(i);
		}
		List<String> modargs = seeifnot(a); //this modifies the args 
		List<Integer> numbersIn = findnums(modargs); //this is index of modargs of numbers
	   	List<Integer> operationsIn = findop(modargs);//this is index of modargs of oporations	
		double finalout = finalcalc(numbersIn, operationsIn, modargs);
		return finalout;
	}

	public static String[] parenthesisCount(String[] args) // this counts the pharenthesis, is used to see if the pharenthesis were inputed right. 
	{
		int opencount = 0;
		int closecount = 0;
		for(int i = 0; i < args.length; i++)
		{
			if(args[i].equals("("))
			{
				opencount++;
			}else if(args[i].equals(")"))
			{
				closecount++;
			}
		}
		if(opencount == closecount)
		{
			return args;
		}else if (opencount < closecount)
		{
			println("more close pharenthesis than open,   attempting to continue anyway",2);
			String[] re = new String[args.length + (closecount - opencount)];
			for(int i = 0; i < (closecount - opencount); i++)
			{
				re[i] = "(";
			}
			for(int i = 0; i < args.length; i++)
			{
				re[i + (closecount - opencount)] = args[i];
			}
			if(dev == true)
			{	
			for(String x : re)
			{
				
				print(x,0);
			}
			}
			return re;
		}else if (opencount > closecount)
		{
			println("more open pharenthesis than close,   attempting to continue anyway",2);
			String[] re = new String[args.length + (opencount - closecount)];
			for(int i = 0; i < args.length; i++)
			{
				re[i] = args[i];
			}
			for(int i = 0; i < (opencount - closecount); i++)
			{
				re[i + args.length] = ")";
			}
			if(dev == true)
			{
				if(dev == true)
				{
					for(String x : re)
					{
						print(x,0);
					}
				}
			}
			return re;
		}else
		{
			println("error of mis matching pharenthesis,  attempting anyway",2);
			return args;
		}
	}


	//sets things up for final calc, makes pharenthesis work.
		public static double finalcalcS(List<Integer> numbersIn, List<Integer> findops, List<String> modargs) //this starts the final calculations 
	{
		List<String> modmod = new ArrayList<String>();
		for(String s : modargs)
		{
			modmod.add(s);
		}
		while(anyfind(modmod, "("))
		{
			if(dev == true)
			{
				println("in while of (, length of modmod =" + modmod.size(),0);
				for(String str : modmod)
				{
					println(str,0);
				}
			}
			int currentIP = 0;
			int farP = 0;
			boolean isCS = false;
			List<Integer> openI = new ArrayList<Integer>();
			List<Integer> closeI = new ArrayList<Integer>();
			boolean closingStart = false;
			int openPos = -1;
			int closePos = -1;
			boolean forStopper = false;
				for(int i = 0; i < modmod.size(); i++)
				{
					if(forStopper == false)
					{
					if(dev == true)
					{
						println("in for",0);
					}
					
					if(modmod.get(i).equals("("))
					{
						openPos = i;
					}
					if(openPos >= 0 && modmod.get(i).equals(")"))
					{
						closePos = i;
						forStopper = true;
						
					}
					}
				}


						if(dev == true)
						{
							println("before for of ( delete",0);
						}
				
						List<String> partCalc = new ArrayList<String>();
						for(int k = openPos + 1; k < closePos; k++)
						{
							partCalc.add(modmod.get(k));
						}
						double partVal = calcStartP(partCalc);
						if(dev == true)
						{
						for(String str : partCalc)
						{
							
							println("partCalc ="+str,0);
						}
							println("part in par = " + partVal,0);
						}
						
						List<String> temp = new ArrayList<String>();
			
						for(int k = 0; k < openPos ; k++)
						{
							if(dev == true)
							{ 
								println("modmod"+ modmod.size(),0);
							}
							temp.add(modmod.get(k));
						}
						temp.add(partVal + "");
						for(int k = closePos + 1; k < modmod.size(); k++)
						{
							temp.add(modmod.get(k));
						}
						modmod.clear();
						for(int k = 0; k < temp.size(); k ++)
						{
							modmod.add(temp.get(k));
							
						}
						if(dev == true)
						{
							for(String str : modmod)
							{
								print(str +",",0);
							}
						}
						
						currentIP++;
					
					
                    
				
			
			
		}
		
		double finalre = calcStartP(modmod);
		
		return finalre;
		
}

	//calculates final output
	public static double finalcalc(List<Integer> numbersIn, List<Integer> findops, List<String> args) // calculates final output 
	{
		List<String> modargs = seeifnot2(args,false);
		if(dev == true)
		{
			println("see if not 2 ",0);
			for(String str : modargs)
			{
				print("see if not 2 " + str + ",",0);
			}
		}
		double output = 0;
		incurrent = 0;
		if(modargs.size() > 0)
		{
		if(isDouble(modargs.get(incurrent)))
		{
			if(!specialNum.containsKey(modargs.get(incurrent)) && !bigspecial.containsKey(modargs.get(incurrent)))
			{
				output = Double.parseDouble(modargs.get(incurrent));	
			}else if (specialNum.containsKey(modargs.get(incurrent)))
			{
				output = specialNum.get(modargs.get(incurrent));
			}else if (bigspecial.containsKey(modargs.get(incurrent)))
			{
				output = bigspecial.get(modargs.get(incurrent)).doubleValue();
			}else
			{
				println("unrecognized charactor in final output start",2);
			}
		}else if(isInteger(modargs.get(incurrent)))
		{
			output = (double) Integer.parseInt(modargs.get(incurrent));
		}else
			{
				println("unrecognized charactor in final output start 2",2);
				
			}
		int operation = 2;
		for(int i = 1; i < modargs.size(); i++)
		{
			incurrent = i;
			if(dev == true)
			{
				println("anyfind with findops" + anyfind(i,findops),0);
				println("findop" + findop(modargs),0);
			}
			if(anyfind(i,findops))
			{
				if(dev == true)
				{
					println("operation redone to" +operation,0);
				}
				String s = modargs.get(i);
				if(operations.containsKey(s))
				{
					operation = operations.get(s);
				}else{
				println("unidentified operation exit 2",2);
				}
				
			}else if(anyfind(i,numbersIn))
			{
				if(dev == true)
				{
					println("numbers start",0);
				}
				if(isInteger(modargs.get(i)))
				{
					double Nint = (double) Integer.parseInt(modargs.get(i));
					output = condensedcalc(output, Nint, operation);

				}else if(isDouble(modargs.get(i)))
				{
					double Ndouble = 0;
					if(!(specialNum.containsKey(modargs.get(incurrent))) && ! bigspecial.containsKey(modargs.get(incurrent)))
					{
						Ndouble = Double.parseDouble(modargs.get(i));
					}else if (specialNum.containsKey(modargs.get(i)))
					{
						Ndouble = specialNum.get(modargs.get(i));
					}else if (bigspecial.containsKey(modargs.get(i)))
					{
						Ndouble = bigspecial.get(modargs.get(i)).doubleValue();
					}else
					{
						println("unrecognized charactor in final output double",2);
					}
					output = condensedcalc(output, Ndouble, operation);
				}
if(dev == true)
{
				println(operation + "",0);
				
				println(output + "",0);
}
operation = 2;
			}
		}
		} else
{
	println("No inputs recognized answer there for will be zero",2);
	output = 0;
}
		return output;
	}



//condensed calculations for above
	public static double condensedcalc(double output, double Nint, int op) // does the condensed calculations after finding the operator, this just takes the operator and does each seprate claculation 
	{
							if(op == 0)
					{
						output = output + Nint;
					}else if(op == 1)
					{
						output = output - Nint;
					}else if(op == 2)
					{
						output = output * Nint;
					}else if(op == 3)
					{
						if(Nint != 0)
						{
							output = output / Nint;
						}else
						{
							println("ERROR",1);

							println("ERROR",1);
							println("ATEMPTED DIVISION BY ZERO",1);
							println("ARE YOU INSANE, THIS COULD DESTABLIZE OUR REALITY",1);
							println("(LARGE EXPLOSION NOICES)",1);
							for(int k = 0;  k < 10; k++)
							{
								println("(LARGE EXPLOSION NOICES)",1);
							}
							System.exit(0);
				
						
				
					}
				{

				}
							
					}else if (op == 4)
					{
						output = Math.pow(output, Nint);
					}else if (op == 5)
					{
						output = Math.pow(output, 1/Nint);
					}else if (op == 6)
					{
						output = factorial(output, Nint);
					}else if (op == 7)
					{
						output = output % Nint;
					}else if (op == 8)
					{
						output = Math.sin(output) * Nint;
					}else if (op == 9)
					{
						output = Math.cos(output) * Nint;
					}else if (op == 10)
					{
						output = Math.tan(output) * Nint;
					}else if (op == 11)
					{
						output = (1/(Math.sin(output))) * Nint;
					}else if (op == 12)
					{
						output = (1/(Math.cos(output))) * Nint;
					}else if (op == 13)
					{
						output = (1/(Math.tan(output))) * Nint;
					}else if (op == 14)
					{
						output = (Math.log(output) / Math.log(2.718281828459045)) * Nint;
					}else if (op == 15)
					{
						output = Math.log(output) / Math.log(Nint);
					}else if (op == 16)
					{
						output = Math.toRadians(output) * Nint;
					}else if (op == 17)
					{
						output = Math.asin(output) * Nint;
					}else if (op == 18)
					{
						output = Math.acos(output) * Nint;
					}else if (op == 19)
					{
						output = Math.atan(output) * Nint;
					} else if (op == 20)
					{
						output = ( output * Math.PI ) / 180;
					} else if (op == 22)
					{
						output = (output / Math.PI) * 180;
						output = output * Nint;
					}else 
					{
						println("unused oporation found ",2);
					}
		return output;
	}

	public static double factorial(double output, double Nint) //this makes a factorial outof 2 double inputs, is better becuase it also decides if something is too big 
	{
		double temp = output;
						if(output > 1000)
						{
							println("No",1);
							println("I don't feel like it",1);
							println("Do you realize how long this would take",1);
							println("I'ma just make it like 1 or something",1);
							output = 1;
						}else if (output > 169.6)
						{
							println("bro why",1);
							println("you think I want to calculate this ",1);
							println("like no, its too high ",1);
							println("I'll  just give you like infinity or something",1);
							for(int i = 0; i < output; i++)
							{
							if((output - 1) > 0)
							{
								temp = temp * (output - i);
							}
							}
							output = temp * Nint;
						}else {
							for(int i = 1; i < output; i++)
							{
								if((output - 1) > 0)
								{
									temp = temp * i;
								}
							}
							output = temp * Nint;
						}
		return output;
	}

	public static List<String> seeifnot(String[] args) // this is all about filtering a string array, taking out what doesn't work and allowing what does
	{
		List<String> temp1 = seeifnotSub(args);
		String[] args1 = new String[temp1.size()];
		for(int i = 0; i < temp1.size(); i++)
		{
			args1[i] = temp1.get(i);
		}
		while(!temp1.equals(seeifnotSub(args1)))
		{
			temp1 = seeifnotSub(args1);
			args1 = new String[temp1.size()];
				for(int i = 0; i < temp1.size(); i++)
			{
				args1[i] = temp1.get(i);
			}
			if(dev == true)
			{
				println("see if not redone again",0);
			}
		}
		temp1 = seeifnotSub(args1);
			args1 = new String[temp1.size()];
				for(int i = 0; i < temp1.size(); i++)
			{
				args1[i] = temp1.get(i);
			}
			if(dev == true)
			{
				println("see if not redone again",0);
			}
		return temp1;
	}

	//returns a modified list of only usable things
	public static List<String> seeifnotSub(String[] args) // this is a sub class of above is run several times from the above and does most of the brunt of above 
	{
		List<String> a = new ArrayList<String>();
		for(int i = 0; i < args.length; i++)
		{
			if(isDouble(args[i]))
			{
				a.add(args[i]);
				opast = false;
			} else if(isInteger(args[i]))
			{
				a.add(args[i]);
				opast = false;
			}else if(anyop(args[i]))
			{
				
				if(opast == true)
				{
					println("two oporators detected in a row at parametor"+i+"will delete second and use first",2);
				}else{
					opast = true;
					a.add(args[i]);
				}
			}else if (args[i].equals("(") || args[i].equals(")"))
			{
				a.add(args[i]);
			}else if (args[i].equals("piB")||args[i].equals("pib")||args[i].equals("Bpi")||args[i].equals("bpi"))
			{
				a.add(args[i]);
				opast = false;
			}else 
			{
				println("undefined charactor at paramenter " + i + " program will attempt to continue anyway",2);
				List<String> b = sepStringAttempt(args[i], false);
				if(b.size() > 0)
				{
					for(int v = 0; v < b.size(); v++)
					{
						a.add(b.get(v));
					}
				}
			}

		}
		return a;
	}
	

	public static List<String> sepStringAttempt(String str, boolean usePiB) // this attempts to separate an unknown string, doesn't work all the time but better than nothing. 
	{
		List<String> re = new ArrayList<String>();
		int typeSH = 0;
		boolean hadD = false;
		boolean hadDW = false;
		List<String> rehold = new ArrayList<String>();
		String reholdS = "";
		String reholdD = "";
		for(int i = 0; i < str.length(); i++)
		{
			int typeS = 0;
			String a = String.valueOf(str.charAt(i));
			if(a.equals("(") || a.equals(")"))
			{
				typeS = -1;
			}else if(isInteger(a) || a.equals("."))
			{
				typeS = 1;
				if(a.equals("."))
				{
					if(hadD == true)
					{
						hadDW = true;
					}else
					{
						hadD = true;
					}
				}
			}else if(operations.containsKey(a))
			{
				typeS = 2;
			}else if(Character.isLetter(str.charAt(i)))
			{
				typeS = 3;
			}else {
				if(dev == true)
				{
					println("unrecognized element at " + i + " this could be becuase it doesn't do letters yet",2);
				}
			}
			if(typeS == 1)
			{
				if(hadDW == false)
				{
					if(typeS != typeSH)
					{
					
						if(!reholdD.equals(""))
						{
							re.add(reholdD);
							reholdD = "";
						}
						re.addAll(rehold);
						rehold.clear();
						reholdD = reholdD + String.valueOf(str.charAt(i));
						if(!reholdS.equals(""))
						{
						if(specialNum.containsKey(reholdS) || operations.containsKey(reholdS) || bigspecial.containsKey(reholdS))
						{
							re.add(reholdS);
							reholdS = "";
						}else if (usePiB == true && reholdS == "piB")
						{
							re.add(reholdS);
							reholdS = "";
						}else 
						{
							if(dev == true)
							{
								println("string split attempt did not recognize string = " + reholdS + " dropping it from string",2);
							}
							reholdS = "";
						}
				
						}
					
						hadD = false;
					}else if (typeS == typeSH)
					{
						reholdD = reholdD + String.valueOf(str.charAt(i));
					}
		
				}else if (hadDW == true)
				{
					if(dev == true)
					{
						println("two decimal places in number, ending number here",0);
					}
					re.addAll(rehold);
					rehold.clear();	
					hadD = false;
				}
			}else if (typeS == -1) 
			{
				if(typeS != typeSH)
					{
					
						if(!reholdD.equals(""))
						{
							re.add(reholdD);
							reholdD = "";
						}
						re.addAll(rehold);
						rehold.clear();
						rehold.add(String.valueOf(str.charAt(i)));
						if(!reholdS.equals(""))
					{
						if(specialNum.containsKey(reholdS) || operations.containsKey(reholdS) || bigspecial.containsKey(reholdS))
						{
							re.add(reholdS);
							reholdS = "";
						}else 
						{
							if(dev == true)
							{
								println("string split attempt did not recognize string = " + reholdS + " dropping it from string",0);
							}
							reholdS = "";
						}
				
					}
					}else if (typeS == typeSH)
					{
						rehold.add(String.valueOf(str.charAt(i)));
					}
			}else if (typeS == 2)
			{
				if(typeS != typeSH)
				{
					re.addAll(rehold);
					rehold.clear();
					rehold.add(String.valueOf(str.charAt(i)));
					if(!reholdS.equals(""))
					{
						if(specialNum.containsKey(reholdS) || operations.containsKey(reholdS) || bigspecial.containsKey(reholdS))
						{
							re.add(reholdS);
							reholdS = "";
						}else 
						{
							if(dev == true)
							{
								println("string split attempt did not recognize string = " + reholdS + " dropping it from string",0);
							}
							reholdS = "";
						}
				
					}
					if(! reholdD.equals(""))
					{
						re.add(reholdD);
						reholdD = "";
					}
					hadD = false;
				}else if (typeS == typeSH)
				{
					if(dev == true)
					{
						println(" operators next to each other in string split attempt, deleting all following in series.",0);
						
					}
					rehold.add(String.valueOf(str.charAt(i)));
				}
			}else if (typeS == 3)
			{
				if(typeS != typeSH)
				{
					re.addAll(rehold);
					if(! reholdD.equals(""))
					{
						re.add(reholdD);
						reholdD = "";
					}
					rehold.clear();
					reholdS = reholdS + String.valueOf(str.charAt(i));
					hadD = false;
				}else if (typeS == typeSH)
				{
					reholdS = reholdS + String.valueOf(str.charAt(i));
				}
			}
			
			typeSH = typeS;
			hadDW = false;
		}
		re.addAll(rehold);
		if(!reholdS.equals("") && (specialNum.containsKey(reholdS) || operations.containsKey(reholdS) || bigspecial.containsKey(reholdS)))
					{
						re.add(reholdS);
						reholdS = "";
					}
		if(!reholdD.equals(""))
					{
						re.add(reholdD);
						reholdS = "";
					}
		return re;
	}

	public static void println(String s, int typep) // a better print method, can do the things and display it too 
	{
		/*
		 * type = 1 is an answer, something to be printed to the answer area 
		 * type = 2 is a major supporter
		 * type = 0 is a dev command 
		 * type = 3 is a progress announcement or other not that inportant thing . 
		 */
		System.out.println(s);
		if(typep == 1)
		{
			SwingApplication.printAnswer(s);
		}
		if(typep == 2)
		{
			SwingApplication.displayD(s,true);
		}
		if(typep == 3)
		{
				if(dev == true) SwingApplication.displayD(s,true);
		}
		if(typep == 0)
		{
			SwingApplication.devlogsD(s,true);
		}
	}

	public static void print(String s, int typep) // a better print method, can do the things and display it too 
	{
		/*
		 * type = 1 is an answer, something to be printed to the answer area 
		 * type = 2 is a major supporter
		 * type = 0 is a dev command 
		 * type = 3 is a progress announcement or other not that inportant thing . 
		 */
		System.out.print(s);
		if(typep == 1)
		{
			SwingApplication.printAnswer(s);
		}
		if(typep == 2)
		{
			SwingApplication.displayD(s,false);
		}
		if(typep == 3)
		{
			if(dev == true) SwingApplication.displayD(s,false);
		}
		if(typep == 0)
		{
			SwingApplication.devlogsD(s,false);
		}
	}

	public static List<String> seeifnot2(List<String> args, boolean BigDQ)//does the normal seeifnot but is when I don't care enough to use parenthesis. takes a boolean for a few reasons, first for is piB is allowed so if it uses big decimals. it stands for Big Decimal questionmark.
	{
		List<String> temp1 = seeifnot2sub(args, BigDQ);
		while(!temp1.equals(seeifnot2sub(temp1, BigDQ)))
		{
			temp1 = seeifnot2sub(temp1, BigDQ);
		}
		return temp1;
	}

	//this also takes out pharenthesis
	public static List<String> seeifnot2sub(List<String> args,boolean BigDQ) // this is just sub of above, does the same continuing with out pharaenthesis and using the BigDQ to see if piB and or pharenthesis are allowed. 
	{
		boolean numFCan = false;
		List<String> a = new ArrayList<String>();
		for(int i = 0; i < args.size(); i++)
		{
			if(numFCan == false && args.get(i).equals(" "))
			{
				println("space detected first in see if not 2,",2);
			}
			if(isDouble(args.get(i)))
			{
				a.add(args.get(i));
				opast = false;
				numFCan = true;
			} else if(isInteger(args.get(i)))
			{
				a.add(args.get(i));
				opast = false;
				numFCan = true;
			}else if(anyop(args.get(i)))
			{
				
				if(numFCan == true)
				{
				
					if(opast == true)
					{
						println("two oporators detected in a row at parametor"+i+"will delete second and use first",2);
					}else{
						opast = true;
						a.add(args.get(i));
					}
				}else 
				{
					if(dev == true)
					{
						println("operater detected first not using",2);
					}
				}
			} else if (args.get(i).equals("piB"))
			{
				a.add(args.get(i));
				opast = false;
				numFCan = true;
			}else 
			{
				
				println("undefined charactor at paramenter " + i + " program will attempt to continue anyway",2);
				List<String> b = sepStringAttempt(args.get(i),BigDQ);
				if(b.size() > 0)
				{
					for(int v = 0; v < b.size(); v++)
					{
						a.add(b.get(v));
					}
				}
			}

		}
		return a;
	}
	
	//any oporation finder returns boolean 
	public static boolean anyop(String s) // this just returns if the given string is an operator 
	{
		if(operations.containsKey(s))
			{
				return true;
			} else{
				return false;
			}

	}
	public static <T> boolean anyfind(List<T> s, T f) // uses generics for an anyfind function, doesn't do that much with the anyop and isinteger and doulbe but still 
	{
		boolean re = false;
		for(T i : s)
		{
			if(i.equals(f))
			{
				re = true;
			}
		}
		return re;

	}

	//this finds the index of opporations 
	public static List<Integer> findop(List<String> args) //finds the indexes of operators 
	{
		List<Integer> a = new ArrayList<Integer>();
		for(int i = 0; i < args.size(); i++)
		{
			if(anyop(args.get(i)) == true)
			{
				if(i != 0)
				{
					a.add(i);
				}else
				{
					println("operator detected first, will not be used",2);
				}
			}
		}
		return a;
	}
	
    //returns a list of the indexes of all doubles. 
	public static List<Integer> findnums(List<String> args) // finds and returns a list of the indexes of all doub;es and stuff 
	{
		 List<Integer> numbers = new ArrayList<Integer>();
		for(int i = 0; i < args.size(); i++)
		{
			if(isDouble(args.get(i)))
			{
				numbers.add(i);
			}else if(isInteger(args.get(i)))
			{
				numbers.add(i);
			}
		}
		return numbers;
	}

    //sees if it is double
	public static boolean isDouble(String str) { // returns true if it is a double or in the specical num 
    	try {
        	Double.parseDouble(str);
        return true;
    		} 
            catch (NumberFormatException nfe) {
			if(!specialNum.containsKey(str) && !bigspecial.containsKey(str))
			{
				if(dev == true)
				{
					println("falsity in is double",0);
				}
				return false;
			}else
			{
				return true;
			}
    	}
    }
	//same as above but for integers
	public static boolean isInteger(String str) { //finds if it is an integer doesn't bother with speical num since all speical nums are doubles 
		try {
	Integer.parseInt(str);
	return true;
		} 
		catch (NumberFormatException nfe) {
		return false;
		}
}

	//see if anything is there
	public static boolean anyfind(int z, List<Integer> a)//another anyfind for reasons, i feel like it ok 
        {
            int s = a.size();
            boolean isThere = false;
            
                for(int i = 0; i < s; i++)
                {
                    if(z == a.get(i))
                    {
                        isThere = true;
                    }
                }
            
            return isThere;
        }
}

class TayFactorial implements Runnable // this class uses a different thread to find the factorials for a taylor series 
{
	private static Thread t; 
	private static String threadName;
	static int tayPres = 1000;
	static double epow = 0;
	static boolean dev = false;

	public TayFactorial(String name, int tayPres, double epow, boolean dev) //constructor does stuff. 
{
	threadName = name;
	this.tayPres = tayPres;
	this.epow = epow;
	this.dev = dev;
}
	
	public void start()//start method for the threads
	{
		if(t == null)
		{
			t = new Thread(this, threadName);
			t.start ();
		}
	}

	
	public void run()//run for the threads, does the things based on the name and then returns the numbers to the thing 
	{
		if (threadName.equals("factorial"))
		{
			if(dev == true)
			{
				math.println("thread working in factorial name = "+ threadName,0);
			}
			BigDecimal x = new BigDecimal(1);
			for(int i = 1; i < tayPres; i++)
			{
				BigDecimal iB = new BigDecimal(i);
				x = x.multiply(iB);
				if(dev == true)
				{
					//println("added to Factorialed =" + Factorialed.get(Factorialed.size() - 1),0);
				}
				
				//new math("fac", x);
				math.Factorialed.add(x);
			}
			if(dev == true)
			{
				math.println("factorial thread done",0);
			}
			t = null;
			
		}else if (threadName.equals("pow"))
		{
			if(dev == true)
			{
				math.println("threading working in pow with name =" + threadName,0);
			}
			BigDecimal xB = new BigDecimal(epow);
			for(int i = 1; i < tayPres; i++)
			{
				if(dev == true)
				{
					//println("added to pow =" + powered.get(powered.size() - 1) + " at index = "+(powered.size() -1),0);
				}
				//new math("pow", xB.pow(i));
				math.powered.add(xB.pow(i));
			}
			if(dev == true)
			{
				math.println("pow thread done",0);
			}
			t = null;
		}
		return;
	}

	public static BigDecimal bigFactorial(double output, double Nint) // does big factorials, not much used anymore. 
	{
		BigDecimal re = new BigDecimal(output);
		for(int i = 1; i < output; i ++)
		{
			BigDecimal m = new BigDecimal(i);
			re = re.multiply(m);
		}
		if(dev == true)
		{
			//println("factorial in big = " + re,0);
		}
		return re;
	}
}

class TayPow implements Runnable // this uses a different thread to do the taylor series powers, 
{
	private static Thread t; 
	private static String threadName;
	static int tayPres = 1000;
	static double epow = 0;
	static boolean dev = false;
	public TayPow(String name, int tayPres, double epow, boolean dev)
{
	threadName = name;
	this.tayPres = tayPres;
	this.epow = epow;
	this.dev = dev;
}

	//start method for the threads
	public void start()
	{
		if(t == null)
		{
			t = new Thread(this, threadName);
			t.start ();
		}
	}

	//run for the threads
	public void run()
	{
		if (threadName.equals("factorial"))
		{
			if(dev == true)
			{
				math.println("thread working in factorial name = "+ threadName,0);
			}
			for(int i = 1; i < tayPres; i++)
			{
				if(dev == true)
				{
					//math.println("added to Factorialed =" + Factorialed.get(Factorialed.size() - 1),0);
				}
				//new math("fac", bigFactorial(i, 1));
				math.Factorialed.add(bigFactorial(i, 1));
			}
		t = null;
		}else if (threadName.equals("pow"))
		{
			if(dev == true)
			{
				math.println("threading working in pow with name =" + threadName,0);
			}
			BigDecimal xB = new BigDecimal(epow);
			for(int i = 1; i < tayPres; i++)
			{
				if(dev == true)
				{
					//math.println("added to pow =" + powered.get(powered.size() - 1) + " at index = "+(powered.size() -1),0);
				}
				//new math("pow", xB.pow(i));
				math.powered.add(xB.pow(i));
			}
			if(dev == true)
			{
				math.println("pow thread done",0);
			}
			t = null;
		}
		return;
	}
	public static BigDecimal bigFactorial(double output, double Nint) //again not much used but does stuff 
	{
		BigDecimal re = new BigDecimal(output);
		for(int i = 1; i < output; i ++)
		{
			BigDecimal m = new BigDecimal(i);
			re = re.multiply(m);
		}
		
		return re;
	}
	
}


class adder implements Runnable //idk i just don't feel like deleting it. 
{
	private static Thread t; 
	private static String threadName;
	static boolean dev = false;
	public adder(String name, int tayPres, double epow, boolean dev)
	{
		threadName = name;
		this.dev = dev;
	}
	//start method for the threads
	public void start()
	{
		if(t == null)
		{
			t = new Thread(this, threadName);
			t.start ();
		}
	}

	//run for the threads
	public void run()
	{
		
	}
}


class SwingApplication { // class that handles some more of the swing elements 

	static final int prec_INIT = 20000;    //initial precision
	static final int prec_MIN = 1; //minimum precision 
	static final int prec_MAX = 100000;//maximum precision
    private static String labelPrefix = "Number of button clicks: "; // label contents
    private static int numClicks = 0; //relic of tests
	static JSlider TaylorPrec = new JSlider(JSlider.HORIZONTAL, prec_MIN, prec_MAX, prec_INIT);//the taylor series precision slider
	static JCheckBox cutoffButton = new JCheckBox(); // a checkbox for whether the taylor calculation is rounded to the max precision set in slider
	static JCheckBox devBut = new JCheckBox(); // checkbox of whether dev mode is pressed 
	static JCheckBox periodCon = new JCheckBox(); 
	static JLabel TaylorLabel = new JLabel("Taylor series amount of precision:");//label for the slider 
	static JLabel equationlabel = new JLabel("Equation Input:"); // equation box label
    static JTextField equationinput = new JTextField(20);//text box for where inputs are inputed.
	static String LastInput = ""; // this holds the last input 
	public static boolean inputdone = false; // if a new input is ready
	static JTextArea txtConsole = new JTextArea(5, 10);//the display for the answers
	static JButton button = new JButton("I'm a Swing button!");
	static JScrollPane srcPane = new JScrollPane(txtConsole, // this control of the display for the answers, makes it scrolly. 
            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
            JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
			
	static JTextArea display = new JTextArea(5, 10); // display for welcome messages and text and stuff 
			
	static JScrollPane displayscroll = new JScrollPane(display, //makes above scroll and stuff
					JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
					JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);

			static JProgressBar progressBar = new JProgressBar(0, 100); // this is the progress bar for the taylor series 
			
			//Where the GUI is constructed:
			
	static JPanel pane = new JPanel();
	static final JLabel label = new JLabel(labelPrefix + "0    ");

	//theme editor label: 
	static JLabel themes = new JLabel("Quick Themes:");
	//theme editor buttons: 
	static JButton darkbutton = new JButton("Dark theme");
	static JButton lightbutton = new JButton("light theme");
	static JButton hackerbutton = new JButton("Hacker Theme");
	



	//these variable hold the current colors. 
	static Color foregroundColor = Color.BLACK;
	static Color backgroundColor = Color.WHITE;

	//getter methods for above colors
	public static Color currentforeGet()
	{
		return foregroundColor;
	}
	public static Color currentbackGet()
	{
		return backgroundColor;
	}

	static GridBagConstraints parm = new GridBagConstraints();
	public Component createComponents() {


		devconsole.setEditable(false);
		txtConsole.setEditable(false);
		display.setEditable(false);
		
		progressBar.setValue(0);
		progressBar.setStringPainted(true);

        
		
					//below starts the slider
					//JSlider TaylorPrec = new JSlider(JSlider.HORIZONTAL, prec_MIN, prec_MAX, prec_INIT);
					//Turn on labels at major tick marks.
					TaylorPrec.setMajorTickSpacing(4000);
					TaylorPrec.setMinorTickSpacing(1000);
					TaylorPrec.setPaintTicks(true);
					TaylorPrec.setPaintLabels(true);

					//below is the cut off check box 
					//In initialization code:
		cutoffButton = new JCheckBox("cut Taylor output based on precision");
		cutoffButton.setMnemonic(KeyEvent.VK_C); 
		cutoffButton.setSelected(true);

		devBut = new JCheckBox("toggle dev logs");
		devBut.setMnemonic(KeyEvent.VK_C); 
		devBut.setSelected(true);

		periodCon = new JCheckBox("toggle Taylor posistion's moved to equal period");
		periodCon.setMnemonic(KeyEvent.VK_C); 
		periodCon.setSelected(true);
    

		//all the active listeners, compressed right there. 
		activeListenersMaker();
        /*
         * An easy way to put space between a top-level container
         * and its contents is to put the contents in a JPanel
         * that has an "empty" border.
         */
        
        pane.setBorder(BorderFactory.createEmptyBorder(
                                        30, //top
                                        30, //left
                                        10, //bottom
                                        30) //right
                                        );
        pane.setLayout(new GridBagLayout());
		
		parm.fill = GridBagConstraints.HORIZONTAL;
		
		valueAddComp();
			
		//default colors 
		setColorEl(Color.WHITE,Color.BLACK);

		

        return pane;
    }
	private void activeListenersMaker()// this makes all the active listeners for all the buttons and activation stuff 
	{
		devBut.setMnemonic(KeyEvent.VK_I);
        devBut.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if(math.dev == false) 
				{
					math.dev = true;
					parm.fill = GridBagConstraints.HORIZONTAL;
					parm.ipady = 600;
					parm.gridheight = 8;
					parm.gridwidth = 1;
					parm.weightx = 0.5;
					parm.weighty = 1;
					parm.gridx = 3;
					parm.gridy = 3;
					pane.add(devscrol,parm);
					pane.revalidate();
				}else
				{
					math.dev = false;
					pane.remove(devscrol);
					pane.revalidate();
				}
				math.println("dev changed to " + math.dev,2);
            }
        });
		periodCon.setMnemonic(KeyEvent.VK_I);
        periodCon.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if(math.dev == true) 
				{
					math.println("periodCon flipped to = "+ ! math.periodRounding ,0);
				}
				if(math.periodRounding == true)
				{
					math.periodRounding = false;
				}else
				{
					math.periodRounding = true;
				}
				math.println("periodCon changed to " + math.periodRounding,2);
            }
        });

        button.setMnemonic(KeyEvent.VK_I);
        button.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                numClicks++;
                label.setText(labelPrefix + numClicks);
            }
        });

		darkbutton.setMnemonic(KeyEvent.VK_I);
        darkbutton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                setColorEl(Color.WHITE, Color.BLACK);
				math.print("theme changed to dark theme",0);
				darkbutton.setBackground(new Color((SwingApplication.currentbackGet().getRed() + 128) / 2,(SwingApplication.currentbackGet().getGreen()+ 128) / 2,(SwingApplication.currentbackGet().getBlue()+ 128) / 2));
            }
        });

		lightbutton.setMnemonic(KeyEvent.VK_I);
        lightbutton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                setColorEl(Color.BLACK, Color.WHITE);
				math.print("theme changed to light theme",0);
				lightbutton.setBackground(new Color((SwingApplication.currentbackGet().getRed() + 128) / 2,(SwingApplication.currentbackGet().getGreen()+ 128) / 2,(SwingApplication.currentbackGet().getBlue()+ 128) / 2));
            }
        });

		hackerbutton.setMnemonic(KeyEvent.VK_I);
        hackerbutton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                setColorEl(Color.GREEN, Color.BLACK);
				math.print("theme changed to hacker theme",0);
				hackerbutton.setBackground(new Color((SwingApplication.currentbackGet().getRed() + 128) / 2,(SwingApplication.currentbackGet().getGreen()+ 128) / 2,(SwingApplication.currentbackGet().getBlue()+ 128) / 2));
            }
        });

		label.setLabelFor(button);


		cutoffButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                if(Taylorcheckchecked == false) {Taylorcheckchecked = true;}else{Taylorcheckchecked = false;}
			math.println("taylor check checked changed to " + Taylorcheckchecked,2);
            }
        });

		equationinput.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                LastInput = equationinput.getText();
				math.println("text box activated with = " + LastInput,0);
				new math(LastInput);
				inputdone = true;
            }
        });

	}
	private static void valueAddComp()//adds all the parts to the fram as well as holding all of their variables posistions etc
	{
		/*
		 * below is addition of all the parts:
		 */

		//srcpane things:
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.ipady = 50;
					parm.gridheight = 1;
					parm.gridwidth = 1;
			parm.gridwidth = 3;
			parm.weightx = 0.0;
			parm.weighty = 1;
			parm.gridx = 0;
			parm.gridy = 0;
			pane.add(srcPane,parm);

		//pane.add(button);
        //pane.add(label);


		//equation parts:
			
			//label
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;

			parm.gridwidth = 1;
			parm.weightx = 0.1;
			parm.weighty = 0.5;
			parm.gridx = 0;
			parm.gridy = 1;
			pane.add(equationlabel,parm);


			//equationinput
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.gridwidth = 2;
			parm.weightx = 1;
			parm.weighty = 0.5;
			parm.gridx = 1;
			parm.gridy = 1;
			pane.add(equationinput,parm);


		//taylor parts

			//label
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			//c.gridwidth = 2;
			parm.weightx = 0.5;
			parm.weighty = 0.5;
			parm.gridx = 1;
			parm.gridy = 3;
			pane.add(TaylorLabel,parm);

			//precision slider
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.gridwidth = 3;
			parm.weightx = 0.0;
			parm.weighty = 0.5;
			parm.gridx = 0;
			parm.gridy = 4;
			pane.add(TaylorPrec,parm);




			//precision cut off button
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.0;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 1;
			parm.gridy = 5;
			pane.add(cutoffButton,parm);

			

			//dev toggle button 
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.5;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 0;
			parm.gridy = 5;
			pane.add(devBut,parm);

			//period con button
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.5;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 2;
			parm.gridy = 5;
			pane.add(periodCon,parm);


			// 3 buttons put in and such 

			//themes label
			parm.gridwidth = 1;
			parm.weighty = 0.5;
			parm.gridx = 0;
			parm.gridy = 8;
			pane.add(themes,parm);

			//light mode
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.0;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 0;
			parm.gridy = 9;
			pane.add(lightbutton,parm);

			//dark mode
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.0;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 1;
			parm.gridy = 9;
			pane.add(darkbutton,parm);

			//hacker mode
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.weightx = 0.0;
			//parm.weighty = 0.5;
			parm.gridwidth = 1;
			parm.gridx = 2;
			parm.gridy = 9;
			pane.add(hackerbutton,parm);


		//progress bar for taylor 
			parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 40;
			parm.gridwidth = 3;
			parm.weightx = 0.1;
			parm.weighty = 0.5;
			parm.gridx = 0;
			parm.gridy = 6;
			pane.add(progressBar,parm);
		
		/*
			//just for dev console not really needed here
		 	parm.fill = GridBagConstraints.HORIZONTAL;
			//c.ipady = 80;
			parm.gridheight = 6;
			parm.gridwidth = 1;
			parm.weightx = 1;
			parm.weighty = 1;
			parm.gridx = 3;
			parm.gridy = 3;
			pane.add(devscrol,parm);
		 */
		// console for displays and stuff 
		parm.fill = GridBagConstraints.HORIZONTAL;
		//c.ipady = 40;
		parm.gridwidth = 3;
		parm.gridheight = 1;
		parm.weightx = 0.1;
		parm.weighty = 0.5;
		parm.gridx = 0;
		parm.gridy = 7;
		pane.add(displayscroll,parm);

	}



	public static void setColorEl(Color colorfor, Color colorback) 	//this can be called to change th colors of everything, if you want to 
	{
		pane.setBackground(colorback);
		label.setForeground(colorfor);
		cutoffButton.setForeground(colorfor);
		cutoffButton.setBackground(colorback);
		TaylorPrec.setForeground(colorfor);
		TaylorPrec.setBackground(colorback);
		TaylorLabel.setForeground(colorfor);
		equationinput.setBackground(colorback);
		equationinput.setForeground(colorfor);
		equationlabel.setBackground(colorback);
		equationlabel.setForeground(colorfor);
		devBut.setForeground(colorfor);
		devBut.setBackground(colorback);
		periodCon.setForeground(colorfor);
		periodCon.setBackground(colorback);
		progressBar.setForeground(colorfor);
		progressBar.setBackground(colorback);
		txtConsole.setForeground(colorfor);
		txtConsole.setBackground(colorback);
		srcPane.setForeground(colorfor);
		srcPane.setBackground(colorback);
		devconsole.setForeground(colorfor);
		devconsole.setBackground(colorback);
		display.setForeground(colorfor);
		display.setBackground(colorback);
		themes.setForeground(colorfor);
		themes.setBackground(colorback);
		lightbutton.setForeground(colorfor);
		lightbutton.setBackground(colorback);
		darkbutton.setForeground(colorfor);
		darkbutton.setBackground(colorback);
		hackerbutton.setForeground(colorfor);
		hackerbutton.setBackground(colorback);
		//add all extra items and stuff here 
		
		//this sets the always variables on 
		backgroundColor = colorback;
		foregroundColor = colorfor;
		math.println("colors have been changed, foreground is now: " + foregroundColor.toString() + " background is now: "  + backgroundColor.toString(),0);
		math.println("colors have been changed, foreground is now: " + foregroundColor.toString() + " background is now: "  + backgroundColor.toString(),1);
	}

	public static int getvalue() // this just gets the value of the taylor precision slider
	{
		//math.println("slider value = " + TaylorPrec.getValue(),0);
		return TaylorPrec.getValue();
	}
	public static void progressUpdate(double a) // this updates the progress of the taylor progress bar 
	{
		progressBar.setValue((int) a);
		//progressBar.setNote(a + "%");
	}

	static boolean Taylorcheckchecked = true;
	public static void itemStateChanged(ItemEvent e) { // listener for the chaning of the taylor checked button 
		Object source = e.getItemSelectable();

		if (source == cutoffButton) {
			//...make a note of it...
		} 

		if (e.getStateChange() == ItemEvent.DESELECTED)
		{
			Taylorcheckchecked = true;
		}
	}
	public static boolean Taylorcheck() // this just returns the variable taylor check checked
	{
		return Taylorcheckchecked;
	}
	public static void printAnswer(String s) // this prints an answer to the answer terminal 
	{
		txtConsole.append(s);
		if(math.dev == true)
		{
			math.println("appending to print answer = " + s,0);
		}
		txtConsole.setCaretPosition(txtConsole.getText().length());
	}
	static JTextArea devconsole = new JTextArea(5, 10); 
		static JScrollPane devscrol = new JScrollPane(devconsole,
            JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
            JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
	public static void devlogsD(String s,boolean ifnewLine ) // this prints something to the dev log box 
	{
		if(ifnewLine == true)
		
			devconsole.append(s + "\n");
		else
		
			devconsole.append(s);
		
		

		devconsole.setCaretPosition(devconsole.getText().length());
		//idk man
	}

	public static void displayD(String s,boolean ifNewLine) // this prints something to the display box 
	{
		if(ifNewLine)
			display.append("\n" + s );
		else 
			display.append("" + s);
		display.setCaretPosition(display.getText().length());
	}
}